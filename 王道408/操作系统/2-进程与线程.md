# 第二章 进程与线程

## 目录
- [第二章 进程与线程](#第二章-进程与线程)
  - [目录](#目录)
- [2.0 错题速览](#20-错题速览)
- [2.1 进程与线程](#21-进程与线程)
  - [2.1.1 进程的概念与特征](#211-进程的概念与特征)
  - [2.1.3 进程的状态与转换](#213-进程的状态与转换)
    - [五个状态](#五个状态)
    - [程序状态转换基本事件](#程序状态转换基本事件)
    - [进程组织方式](#进程组织方式)
  - [2.1.4 进程控制](#214-进程控制)
    - [创建](#创建)
    - [终止](#终止)
    - [阻塞、唤醒](#阻塞唤醒)
  - [2.1.5 进程的通信](#215-进程的通信)
    - [共享存储](#共享存储)
    - [消息传递](#消息传递)
    - [管道通信](#管道通信)
    - [信号](#信号)
  - [2.1.6 线程和多线程模型](#216-线程和多线程模型)
    - [基本概念](#基本概念)
    - [进程线程的比较](#进程线程的比较)
    - [线程的属性](#线程的属性)
    - [实现方式](#实现方式)
      - [用户级线程 —— 多对一模型](#用户级线程--多对一模型)
      - [内核级线程 —— 一对一模型](#内核级线程--一对一模型)
      - [组合方式 —— 多对多](#组合方式--多对多)
    - [理解](#理解)
  - [2.1.7 整理](#217-整理)
    - [进程与程序](#进程与程序)
    - [进程基本状态](#进程基本状态)
    - [PCB](#pcb)
    - [信号相关](#信号相关)
    - [线程](#线程)
    - [关于进程状态的转换](#关于进程状态的转换)
    - [终止进程的操作](#终止进程的操作)

# 2.0 错题速览

- 2.1 T3、4、9、13、24、32、35、38、42、51、72、74

# 2.1 进程与线程

程序：静态

进程：动态

## 2.1.1 进程的概念与特征

进程实体：

- 程序段：存放指令序列
- 相关数据段：
- PCB
  - 进程描述信息，PID&用户标识符
  - 分配的资源
  - 运行情况：CPU使用时间、磁盘使用情况、网络流量使用情况
  - 处理机相关信息：即CPU上下文，各寄存器的值。以便重新执行时，能从断点继续执行

特征：

- 动态性
- 并发性：与其他进程并发
- 独立性：独立运行、独立获得资源、独立接受调度
- 异步性 ：与其他进程独立、不可预知
- 结构性

## 2.1.3 进程的状态与转换

### 五个状态

前3个为基本状态

1. 运行态
2. 就绪态 —— 就绪队列
3. 阻塞态 —— 因等待I/O完成或各种阻塞原因
4. 创建态 —— 尚未完成创建工作
5. 终止态 —— 等待资源释放和回收

### 程序状态转换基本事件

- 就绪态 -> 运行态：获得CPU资源
- 运行态 -> 就绪态：时间片用完/被剥夺CPU
- 运行态 -> 阻塞态：请求资源的使用分配/等待某一事件完成（如I/O完成）  **系统调用**
- 阻塞态 -> 就绪态：进程等待的事件到来，阻塞变就绪

### 进程组织方式

链接方式：

- 按状态将PCB分为多个队列
- OS持有指向各个队列的指针

索引方式

- 索引表
- 持有指向各个索引表的指针

## 2.1.4 进程控制

实现创建进程、进程状态转换、撤销已有进程

原语：具有原子性，一气呵成不可中断

- 关中断、开中断实现

### 创建

- 父进程子进程：子进程可继承父进程所拥有的资源，终止时还给父进程
- 创建原语：
  - 分配PID，申请空白PCB（若申请PCB失败则创建失败）
  - 分配所需资源
  - 初始化PCB
  - PCB插入就绪队列 —— 创建态->就绪态
- 引起创建进程的事件：
  - 用户登录：用户登录成功就会创建
  - 作业调度
    - 作业：外存中等待调入内存执行的程序
  - 提供服务
    - 申请打开终端etc.
  - 应用请求

### 终止

- 撤销原语
  - 找到PCB
  - 剥夺CPU
  - 终止其所有子进程
  - 资源还给其父进程/OS
  - 将PCB从队列（链表）删除

- 引起进程终止的事件
  - 正常结束，exit系统调用
  - 异常结束（abort）
  - 用户干预

### 阻塞、唤醒

- 阻塞原语
  - 找到PCB
  - 保护进程运行现场，阻塞态，终止进程运行
  - PCB插入相关阻塞队列

- 切换原语 —— 改变两个进程的state
  - 保存运行环境，存入PCB
  - PCB移入相应队列
  - 选另一个进程执行，更新其PCB
  - 根据PCB恢复其运行环境

- 唤醒原语 —— 事件出现后，调用唤醒原语，将等待该事件的进程唤醒
  - 在事件的等待队列中找到相应进程的PCB
  - 将其从等待队列中移出，变就绪态
  - PCB插入就绪队列

## 2.1.5 进程的通信

需要OS支持，因为各进程内存地址空间相互独立，不可以读取其他进程的数据

### 共享存储

- 直接通过共享存储区实现

- 互斥访问

- Linux中

  - shm_open

  - mmap系统调用，通过增加页表项/段表项，将这片共享内存区映射到各自的地址空间中

- 分类

  - 基于数据结构的共享 —— 低级通信（限制太多了）
  - 基于存储区的共享

### 消息传递

- 格式化消息
- 发送、接收消息两个原语进行交换
- 消息头|消息体
- 分类
  - 直接通信方式，指明进程ID
    - P发送给Q，使用发送原语send
    - msg进入进程Q的消息队列
    - Q接收原语receive（需要点名发送方P）
    - OS检查Q的消息队列，找到P发的
  - 间接通信方式，通过信箱 —— 也叫信箱通信方式
    - P发送给中间实体（信箱），Q从信箱接收
    - 只指明信箱，不指明进程id

### 管道通信

特殊共享文件，pipe，大小固定，单向传输（半双工通信）

需要实现双工通信，需要两个管道

一个管道允许多个写进程，**一个读进程** —— systemV

- 但Linux是允许多个写、多个 读，OS让各个进程轮流读

管道非空，可读；管道非满，可写

提供三种能力

- 互斥：一个进程读写时，其他进程必须等待
- 同步：写一定数量后，写进程阻塞，直到读出后才将写唤醒
- 确定对方存在

子进程也可继承父进程的管道

### 信号

用于通知进程发生某个事件的机制，不同系统时间对应不同信号类型 —— **实现进程间通信**

**信号的保存**

- N种信号，不少于N bit的位向量
- pending位向量：待处理信号
- 还有blocked位向量：信号掩码（屏蔽哪些信号）
  - 1表示阻塞
  - pendign & ~blocked

**信号发送两种方式**

- 内核给某个进程发送信号
  - 内核检测到某个特定系统事件，就给进程发送信号（例如进程使用非法指令，发送SIGILL信号(序号4)）
- 一个进程给另一个进程发送信号
  - 要求内核发送一个信号到目的进程
  - 也可以给自己发送信号

**信号处理方式**

- 执行默认信号处理程序
- 执行进程定义的信号处理程序
  - 进程自己可以定义收到信号的行为

**什么时候处理信号**

- 进程从内核态转为用户态时，例行检查是否有待处理信号
- 运行完处理程序，通常返回程序的下一条指令，除非阻塞/终止

**信号vs异常？**

- 信号可以作为异常的配套机制，进程对OS的异常处理进行补充
- 有些异常可由内核完全全部处理 —— 不需信号机制
- 有些无法全部处理，需用户进程配合
  - 比如计算机程序**整数除以0**
  - 接收OS的相关信号不终止进程，而是打印出某个信息以通知除以0

## 2.1.6 线程和多线程模型

### 基本概念

轻量级线程，最基本的CPU执行单元

- 线程ID
- PC
- 寄存器集合和堆栈（保存局部变量和返回地址）
- 就绪、阻塞、运行三种基本状态

进程作为CPU外系统资源的分配单元；线程作为CPU的分配单元

### 进程线程的比较

|          | 进程                                   | 线程                                                         |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| 调度     | 每次调度需上下文切换                   | 线程是独立调度的基本单位                                     |
| 并发性   | 进程间可并发                           | 进程中的线程也可并发，提高系统资源利用率吞吐量               |
| 拥有资源 | 系统资源                               | 不独立拥有，但可以访问隶属进程的系统资源<br />若它拥有资源则线程失去意义了 |
| 独立性   | 独立                                   | 共享                                                         |
| 系统开销 | 创建撤销开销大<br />切换时需上下文切换 | 切换只需保存、设置少量寄存器内容<br />同步通信实现非常容易   |

### 线程的属性

线程主要属性

- CPU调度单位
- 多CPU每个线程可占用不同CPU
- TCB、线程ID
  - 线程标识符
  - PC
  - 其他寄存器 —— 计算中间结果
  - 堆栈指针
  - 线程运行状态 —— 运行就绪阻塞
  - 优先级 —— 线程调度、资源分配的参考
- 几乎不拥有系统资源
- 共享
- 同一进程中线程切换，不引起进程切换
- 不同进程中线程切换，引起进程切换
- 切换同进程线程，系统开销小

### 实现方式

#### 用户级线程 —— 多对一模型

特点：

- 线程管理：进程完成，并非OS完成

- 线程切换：不需要CPU变态

- OS意识不到线程存在 —— 仅用户能感知到

优点：

- 开销小、效率高——不需要CPU切换状态

缺点：

- 一个用户级线程阻塞，整个进程都会被阻塞，并发度不高

#### 内核级线程 —— 一对一模型

特点：

- OS实现线程管理
- 切换：CPU变态
- OS能察觉到

优点：

- 并发能力强 —— 多线程可在多核处理机上并行执行

缺点

- 调度开销较大 —— 因为线程调度管理在内核实现

#### 组合方式 —— 多对多

### 理解

- 用户级线程：代码逻辑的载体
- 内核级线程：运行机会的载体 —— 它才是处理机分配的单位

## 2.1.7 整理

### 进程与程序

- 进程与程序的根本区别：动态与静态
  - 引入进程：从变化角度动态分析和研究程序的执行
- 进程与程序的一些说法
  - 一个进程在生命周期中可执行多个程序
  - 一个进程同一时刻不可能同时执行多个程序
  - 一个程序的多次运行可形成多个不同进程
  - 一个程序一次执行也可能产生多个进程，fork(), create(), etc.

### 进程基本状态

- n个进程，1CPU
  - 同时最多n-1个就绪态，1个必定在运行态
  - 同时最多n个阻塞态 —— 死锁
  - 系统中若没有运行进程，**则必定没有就绪进程**，因为系统不会允许

### PCB

PCB包含CPU现场，即有CPU状态

全局变量仅依赖于用户代码，并不存在于PCB中

### 信号相关

- 有些信号的处理只能执行OS默认处理程序
  - **不能**被用户自定义
- OS内核对每种信号都有default处理程序
  - 为空也算有

### 线程

- 线程包含CPU现场，可以独立执行程序
  - CPU现场包含PC，PSW，GPRs，栈指针
  - 线程是CPU调度的基本单位，是可以独立执行程序的
- 同一线程之间通信方式
  - 共享存储区
  - 线程库提供的通信接口
- 线程的优点
  - 提高系统并发性
  - 节约系统资源 —— **优化了进程调度的时间，节省的比浪费多得多**
  - 便于进程通信
- 缺点
  - 没之前安全了 —— 一个线程出错影响整个进程
- 内核级线程vs用户级线程
  - 注意是它俩相互比较，是要看相互之间的优点的

### 关于进程状态的转换

- 一些操作的状态变化
  - 阻塞进程、CPU调度、唤醒进程
    - 前：用/内
    - 执行中：内
    - 后：用/内
  - 执行系统调用
    - 前：用户使用系统调用申请系统完成
    - 中：内核态
    - 后：返回原进程下一条指令/新进程

### 终止进程的操作

- 回收：设备、内存
- 释放PCB
- **不一定**终止子进程 —— 有的操作系统不这么设计
