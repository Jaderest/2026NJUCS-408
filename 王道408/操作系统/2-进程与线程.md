# 第二章 进程与线程

## 目录
- [第二章 进程与线程](#第二章-进程与线程)
  - [目录](#目录)
- [2.0 错题速览](#20-错题速览)
- [2.1 进程与线程](#21-进程与线程)
  - [2.1.1 进程的概念与特征](#211-进程的概念与特征)
  - [2.1.3 进程的状态与转换](#213-进程的状态与转换)
    - [五个状态](#五个状态)
    - [程序状态转换基本事件](#程序状态转换基本事件)
    - [进程组织方式](#进程组织方式)
  - [2.1.4 进程控制](#214-进程控制)
    - [创建](#创建)
    - [终止](#终止)
    - [阻塞、唤醒](#阻塞唤醒)
  - [2.1.5 进程的通信](#215-进程的通信)
    - [共享存储](#共享存储)
    - [消息传递](#消息传递)
    - [管道通信](#管道通信)
    - [信号](#信号)
  - [2.1.6 线程和多线程模型](#216-线程和多线程模型)
    - [基本概念](#基本概念)
    - [进程线程的比较](#进程线程的比较)
    - [线程的属性](#线程的属性)
    - [实现方式](#实现方式)
      - [用户级线程 —— 多对一模型](#用户级线程--多对一模型)
      - [内核级线程 —— 一对一模型](#内核级线程--一对一模型)
      - [组合方式 —— 多对多](#组合方式--多对多)
    - [理解](#理解)
  - [2.1.7 整理](#217-整理)
    - [进程与程序](#进程与程序)
    - [进程基本状态](#进程基本状态)
    - [PCB](#pcb)
    - [信号相关](#信号相关)
    - [线程](#线程)
    - [关于进程状态的转换](#关于进程状态的转换)
    - [终止进程的操作](#终止进程的操作)
- [2.2 CPU调度](#22-cpu调度)
  - [2.2.1 调度的概念](#221-调度的概念)
    - [调度的层次](#调度的层次)
  - [2.2.2\&4 调度的实现](#2224-调度的实现)
    - [时机](#时机)
    - [进程调度方式](#进程调度方式)
    - [调度器/调度程序](#调度器调度程序)
    - [闲逛进程](#闲逛进程)
  - [2.2.3 调度的目标](#223-调度的目标)
    - [CPU利用率](#cpu利用率)
    - [系统吞吐量](#系统吞吐量)
    - [周转时间](#周转时间)
    - [等待时间](#等待时间)
    - [响应时间](#响应时间)
  - [2.2.5 调度算法](#225-调度算法)
    - [先来先服务FCFS](#先来先服务fcfs)
    - [短作业优先SJF/SPF](#短作业优先sjfspf)
    - [抢占式最短作业优先/最短剩余时间优先](#抢占式最短作业优先最短剩余时间优先)
    - [高响应比优先HRRN](#高响应比优先hrrn)
    - [时间片轮转](#时间片轮转)
    - [优先级调度算法](#优先级调度算法)
    - [多级反馈队列调度算法](#多级反馈队列调度算法)
    - [多级队列调度算法](#多级队列调度算法)
    - [**多处理机调度(important)**](#多处理机调度important)
      - [方案一：公共就绪队列](#方案一公共就绪队列)
      - [方案二：私有就绪队列](#方案二私有就绪队列)
  - [整理](#整理)
    - [进程进入临界区在退出前，状态变化](#进程进入临界区在退出前状态变化)
    - [线程进程切换需要进行的操作](#线程进程切换需要进行的操作)
    - [满足实时性的调度方法](#满足实时性的调度方法)
    - [多级反馈队列的特点](#多级反馈队列的特点)
    - [改变进程优先级的时机](#改变进程优先级的时机)
    - [可以处理机调度的时机](#可以处理机调度的时机)
    - [调度的次数](#调度的次数)

# 2.0 错题速览

- 2.1 T3、4、9、13、24、32、35、38、42、51、72、74

# 2.1 进程与线程

程序：静态

进程：动态

## 2.1.1 进程的概念与特征

进程实体：

- 程序段：存放指令序列
- 相关数据段：
- PCB
  - 进程描述信息，PID&用户标识符
  - 分配的资源
  - 运行情况：CPU使用时间、磁盘使用情况、网络流量使用情况
  - 处理机相关信息：即CPU上下文，各寄存器的值。以便重新执行时，能从断点继续执行

特征：

- 动态性
- 并发性：与其他进程并发
- 独立性：独立运行、独立获得资源、独立接受调度
- 异步性 ：与其他进程独立、不可预知
- 结构性

## 2.1.3 进程的状态与转换

### 五个状态

前3个为基本状态

1. 运行态
2. 就绪态 —— 就绪队列
3. 阻塞态 —— 因等待I/O完成或各种阻塞原因
4. 创建态 —— 尚未完成创建工作
5. 终止态 —— 等待资源释放和回收

### 程序状态转换基本事件

- 就绪态 -> 运行态：获得CPU资源
- 运行态 -> 就绪态：时间片用完/被剥夺CPU
- 运行态 -> 阻塞态：请求资源的使用分配/等待某一事件完成（如I/O完成）  **系统调用**
- 阻塞态 -> 就绪态：进程等待的事件到来，阻塞变就绪

### 进程组织方式

链接方式：

- 按状态将PCB分为多个队列
- OS持有指向各个队列的指针

索引方式

- 索引表
- 持有指向各个索引表的指针

## 2.1.4 进程控制

实现创建进程、进程状态转换、撤销已有进程

原语：具有原子性，一气呵成不可中断

- 关中断、开中断实现

### 创建

- 父进程子进程：子进程可继承父进程所拥有的资源，终止时还给父进程
- 创建原语：
  - 分配PID，申请空白PCB（若申请PCB失败则创建失败）
  - 分配所需资源
  - 初始化PCB
  - PCB插入就绪队列 —— 创建态->就绪态
- 引起创建进程的事件：
  - 用户登录：用户登录成功就会创建
  - 作业调度
    - 作业：外存中等待调入内存执行的程序
  - 提供服务
    - 申请打开终端etc.
  - 应用请求

### 终止

- 撤销原语
  - 找到PCB
  - 剥夺CPU
  - 终止其所有子进程
  - 资源还给其父进程/OS
  - 将PCB从队列（链表）删除

- 引起进程终止的事件
  - 正常结束，exit系统调用
  - 异常结束（abort）
  - 用户干预

### 阻塞、唤醒

- 阻塞原语
  - 找到PCB
  - 保护进程运行现场，阻塞态，终止进程运行
  - PCB插入相关阻塞队列

- 切换原语 —— 改变两个进程的state
  - 保存运行环境，存入PCB
  - PCB移入相应队列
  - 选另一个进程执行，更新其PCB
  - 根据PCB恢复其运行环境

- 唤醒原语 —— 事件出现后，调用唤醒原语，将等待该事件的进程唤醒
  - 在事件的等待队列中找到相应进程的PCB
  - 将其从等待队列中移出，变就绪态
  - PCB插入就绪队列

## 2.1.5 进程的通信

需要OS支持，因为各进程内存地址空间相互独立，不可以读取其他进程的数据

### 共享存储

- 直接通过共享存储区实现

- 互斥访问

- Linux中

  - shm_open

  - mmap系统调用，通过增加页表项/段表项，将这片共享内存区映射到各自的地址空间中

- 分类

  - 基于数据结构的共享 —— 低级通信（限制太多了）
  - 基于存储区的共享

### 消息传递

- 格式化消息
- 发送、接收消息两个原语进行交换
- 消息头|消息体
- 分类
  - 直接通信方式，指明进程ID
    - P发送给Q，使用发送原语send
    - msg进入进程Q的消息队列
    - Q接收原语receive（需要点名发送方P）
    - OS检查Q的消息队列，找到P发的
  - 间接通信方式，通过信箱 —— 也叫信箱通信方式
    - P发送给中间实体（信箱），Q从信箱接收
    - 只指明信箱，不指明进程id

### 管道通信

特殊共享文件，pipe，大小固定，单向传输（半双工通信）

需要实现双工通信，需要两个管道

一个管道允许多个写进程，**一个读进程** —— systemV

- 但Linux是允许多个写、多个 读，OS让各个进程轮流读

管道非空，可读；管道非满，可写

提供三种能力

- 互斥：一个进程读写时，其他进程必须等待
- 同步：写一定数量后，写进程阻塞，直到读出后才将写唤醒
- 确定对方存在

子进程也可继承父进程的管道

### 信号

用于通知进程发生某个事件的机制，不同系统时间对应不同信号类型 —— **实现进程间通信**

**信号的保存**

- N种信号，不少于N bit的位向量
- pending位向量：待处理信号
- 还有blocked位向量：信号掩码（屏蔽哪些信号）
  - 1表示阻塞
  - pendign & ~blocked

**信号发送两种方式**

- 内核给某个进程发送信号
  - 内核检测到某个特定系统事件，就给进程发送信号（例如进程使用非法指令，发送SIGILL信号(序号4)）
- 一个进程给另一个进程发送信号
  - 要求内核发送一个信号到目的进程
  - 也可以给自己发送信号

**信号处理方式**

- 执行默认信号处理程序
- 执行进程定义的信号处理程序
  - 进程自己可以定义收到信号的行为

**什么时候处理信号**

- 进程从内核态转为用户态时，例行检查是否有待处理信号
- 运行完处理程序，通常返回程序的下一条指令，除非阻塞/终止

**信号vs异常？**

- 信号可以作为异常的配套机制，进程对OS的异常处理进行补充
- 有些异常可由内核完全全部处理 —— 不需信号机制
- 有些无法全部处理，需用户进程配合
  - 比如计算机程序**整数除以0**
  - 接收OS的相关信号不终止进程，而是打印出某个信息以通知除以0

## 2.1.6 线程和多线程模型

### 基本概念

轻量级线程，最基本的CPU执行单元

- 线程ID
- PC
- 寄存器集合和堆栈（保存局部变量和返回地址）
- 就绪、阻塞、运行三种基本状态

进程作为CPU外系统资源的分配单元；线程作为CPU的分配单元

### 进程线程的比较

|          | 进程                                   | 线程                                                         |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| 调度     | 每次调度需上下文切换                   | 线程是独立调度的基本单位                                     |
| 并发性   | 进程间可并发                           | 进程中的线程也可并发，提高系统资源利用率吞吐量               |
| 拥有资源 | 系统资源                               | 不独立拥有，但可以访问隶属进程的系统资源<br />若它拥有资源则线程失去意义了 |
| 独立性   | 独立                                   | 共享                                                         |
| 系统开销 | 创建撤销开销大<br />切换时需上下文切换 | 切换只需保存、设置少量寄存器内容<br />同步通信实现非常容易   |

### 线程的属性

线程主要属性

- CPU调度单位
- 多CPU每个线程可占用不同CPU
- TCB、线程ID
  - 线程标识符
  - PC
  - 其他寄存器 —— 计算中间结果
  - 堆栈指针
  - 线程运行状态 —— 运行就绪阻塞
  - 优先级 —— 线程调度、资源分配的参考
- 几乎不拥有系统资源
- 共享
- 同一进程中线程切换，不引起进程切换
- 不同进程中线程切换，引起进程切换
- 切换同进程线程，系统开销小

### 实现方式

#### 用户级线程 —— 多对一模型

特点：

- 线程管理：进程完成，并非OS完成

- 线程切换：不需要CPU变态

- OS意识不到线程存在 —— 仅用户能感知到

优点：

- 开销小、效率高——不需要CPU切换状态

缺点：

- 一个用户级线程阻塞，整个进程都会被阻塞，并发度不高

#### 内核级线程 —— 一对一模型

特点：

- OS实现线程管理
- 切换：CPU变态
- OS能察觉到

优点：

- 并发能力强 —— 多线程可在多核处理机上并行执行

缺点

- 调度开销较大 —— 因为线程调度管理在内核实现

#### 组合方式 —— 多对多

### 理解

- 用户级线程：代码逻辑的载体
- 内核级线程：运行机会的载体 —— 它才是处理机分配的单位

## 2.1.7 整理

### 进程与程序

- 进程与程序的根本区别：动态与静态
  - 引入进程：从变化角度动态分析和研究程序的执行
- 进程与程序的一些说法
  - 一个进程在生命周期中可执行多个程序
  - 一个进程同一时刻不可能同时执行多个程序
  - 一个程序的多次运行可形成多个不同进程
  - 一个程序一次执行也可能产生多个进程，fork(), create(), etc.

### 进程基本状态

- n个进程，1CPU
  - 同时最多n-1个就绪态，1个必定在运行态
  - 同时最多n个阻塞态 —— 死锁
  - 系统中若没有运行进程，**则必定没有就绪进程**，因为系统不会允许

### PCB

PCB包含CPU现场，即有CPU状态

全局变量仅依赖于用户代码，并不存在于PCB中

### 信号相关

- 有些信号的处理只能执行OS默认处理程序
  - **不能**被用户自定义
- OS内核对每种信号都有default处理程序
  - 为空也算有

### 线程

- 线程包含CPU现场，可以独立执行程序
  - CPU现场包含PC，PSW，GPRs，栈指针
  - 线程是CPU调度的基本单位，是可以独立执行程序的
- 同一线程之间通信方式
  - 共享存储区
  - 线程库提供的通信接口
- 线程的优点
  - 提高系统并发性
  - 节约系统资源 —— **优化了进程调度的时间，节省的比浪费多得多**
  - 便于进程通信
- 缺点
  - 没之前安全了 —— 一个线程出错影响整个进程
- 内核级线程vs用户级线程
  - 注意是它俩相互比较，是要看相互之间的优点的

### 关于进程状态的转换

- 一些操作的状态变化
  - 阻塞进程、CPU调度、唤醒进程
    - 前：用/内
    - 执行中：内
    - 后：用/内
  - 执行系统调用
    - 前：用户使用系统调用申请系统完成
    - 中：内核态
    - 后：返回原进程下一条指令/新进程

### 终止进程的操作

- 回收：设备、内存
- 释放PCB
- **不一定**终止子进程 —— 有的操作系统不这么设计

# 2.2 CPU调度

## 2.2.1 调度的概念

### 调度的层次

- 高级调度：**作业调度**
  - 作业：某一具体任务 —— 让OS启动一个程序，处理一个具体的任务
  - 从外存作业后备队列挑选一个作业调入内存，并创建进程
  - 每个作业在生命周期只**调入一次，调出一次**
- 中级调度：内存调度
  - 内存不足：进程暂时调到外存
  - 调到外存的进程状态挂起状态，进程PCB组织程挂起队列
  - 挂起态 -> 就绪态
- 低级调度：**进程调度**
  - 最基本的调度，频率很高
- 进程挂起态与七状态模型

![七状态模型](./2-pic/七状态模型.png)

## 2.2.2&4 调度的实现

### 时机

**进程主动放弃处理机**

- 正常终止
- 运行中异常而终止
- 主动阻塞（等待I/O）

**被动放弃处理机**

- 时间片用完
- 更紧急的事需要处理（I/O中断）
- 更高优先级进程进入就绪队列

**不能进行的情况**

- 处理中断的过程中
- 进程在OS内核程序临界区中不能调度切换
  - 临界资源：互斥访问
  - 内核程序临界区 vs 临界区
  - 内核程序临界区：访问某种内核数据结构（例如进程就绪队列），需要尽快执行完并释放，否则极有可能死锁etc
  - 临界区：例如打印机，应该进行进程调度，并且不会影响到OS的正常运行，理应让出
- 原子操作过程中

**进程切换与过程**

- 狭义进程调度：从就绪队列中选中一个要运行的进程
  - 可以是刚刚暂停的，也可以是另一个
- 进程切换：必定是让另一个进程占用处理机
- 广义进程调度：选择一个进程&进程切换
  - 元进程各种数据保存
  - 新进程数据恢复
  - PC、PSW、各寄存器等处理机现场信息
- 进程切换是有代价的

### 进程调度方式

- 非剥夺调度，非抢占方式
  - 无法及时处理紧急任务
  - 实现简单，调度开销小
- 剥夺调度方式，抢占方式

### 调度器/调度程序

调度程序

- 调度算法
- 时间片大小

触发调度程序

- 创建新进程
- 进程退出
- 进程阻塞
- I/O中断发生（可能唤醒某些阻塞进程）
- **只要就绪队列改变就会触发**
- 若抢占式，则每个时钟中断/k个时钟中断，都会触发

### 闲逛进程

Idle Process

- 优先级最低
- 0地址指令，无需访存、访问寄存器 —— 能耗低
- 指令末尾例行检查中断

## 2.2.3 调度的目标

学会&计算

### CPU利用率

- CPU利用率 = 忙碌时间/总时间
- 其他设备利用率

- 甘特图

### 系统吞吐量

- 吞吐量 = 总完成作业数量/总完成时间

### 周转时间

- 作业提交 到 作业完成 的时间
  - 等待作业调度的时间
  - 就绪队列等待时间 —— 多次
  - CPU执行时间 —— 多次
  - 进程等待I/O完成时间 —— 多次
- 周转时间 = 完成 - 提交
- 平均周转时间 = 各周转时间之和 / 作业数
- 带权周转时间 = 作业周转时间 / 实际运行时间  >= 1
  - 越小越好
- 平均带权周转时间

### 等待时间

- 进程：建立进程后等待被服务时间之和（但是不能计入等待I/O的时间）

- 作业：建立进程等待时间 + 作业在外存后备队列中等待时间

- 平均等待时间

### 响应时间

- 提交请求到首次响应所用时间

## 2.2.5 调度算法

调度算法学习思路：

- 思想
- 规则
- 适用于作业调度/进程调度
- 抢占式/非抢占式
- 优点/缺点
- 饥饿？

### 先来先服务FCFS

- 公平角度
- 按到达时间
- 作业调度 & 进程调度

- 非抢占
- 优缺点
  - 实现简单、效率低
  - 利于长作业，短作业不利
  - 利于CPU繁忙型作业，不利于I/O繁忙型作业
- 不会饥饿
- **计算小心**：
  - 有I/O操作的话，等待时间=周转-运行-I/O操作时间

### 短作业优先SJF/SPF

- 最短平均等待时间，最少平均周转时间，最少平均带权周转时间
- 后备队列中选估计运行时间最短的作业/进程调度
- 非抢占式
  - 也有抢占式版本：最短剩余时间优先SRTN
- 优缺点
  - 平均等待时间、平均周转时间、平均带权周转时间最短
  - 不一定能真正短作业优先
- 饥饿

### 抢占式最短作业优先/最短剩余时间优先

- 若题目未说明，则默认**非抢占式**

- 每当有进程加入就绪队列时，发生调度；进程完成时也需要调度
- 新到达进程比正在运行进程剩余时间更短，则抢占

### 高响应比优先HRRN

兼顾等待时间&运行时间

- 调度时，计算响应比，选最高的
  - 响应比 = （等待时间+要求服务时间）/要求服务时间
- 非抢占：结束/主动阻塞时，才需要调度

- 不会饥饿

### 时间片轮转

- 公平服务
- 进程调度 —— 关于处理机的时间片
- 一个进程下处理机、同时刻新进程到达，默认新到达进程先进入就绪队列
- 时间片太小：切换过于频繁（切换到开销不超过1%）
- 时间片太大：退化成FCFS
- 优点
  - 公平、响应快，分时OS
- 缺点：不适于紧急

### 优先级调度算法

- 作业调度&进程调度 —— 之后的I/O调度
- 抢占&非抢占
- **优先数**越大，**优先级**越高
- 就绪队列未必只有一个
- 静态优先级：创建进程确定，之后一直不变
- 动态优先级：初值&之后动态调整
  - 追求公平、提升资源利用率来调整
  - 如等待时间长
  - 占用CPU时间长
  - 频繁I/O操作
- 优先级
  - 系统进程高于用户进程
  - 前台进程高于后台进程
  - OS偏好I/O型进程（早进I/O早并行，尽早让I/O设备开始工作）
- 会饥饿

### 多级反馈队列调度算法

- 抢占式算法：被抢占的放回它之前在的位置

- 设置多级就绪队列
  - 优先级高到低，**时间片**小到大
  - 只有上面队列都为空的时候，才会为后面的进程分配时间片

- 优点
  - 各类进程相对公平
  - 响应较快
  - 短进程较少时间可完成
  - 不必估计运行时间
  - 可灵活调整优先级 —— 进程因I/O阻塞，则阻塞完成后放回原队列
- 会导致饥饿

### 多级队列调度算法

- 设置多个队列
- 固定优先级
  - 系统进程
  - 交互式进程
  - 批处理进程
- 时间片划分
  - 50%，40%，10%
- 各队列不同调度策略

### **多处理机调度(important)**

- 单处理机vs多处理机调度
  - 哪个先上
  - 上哪个CPU
- 目标：
  - **负载均衡**——每个CPU都同等忙碌
  - **处理机亲和性**——一个进程调入同一个CPU上运行，充分发挥CPU缓存作用

#### 方案一：公共就绪队列

- 所有CPU共享同一个就绪进程队列（内核区）
- 每个CPU时运行调度程序，访问公共就绪队列，选择一个进程运行
  - 公共就绪队列需要**上锁**
- 优点
  - 天然实现负载均衡
- 缺点
  - 频繁切换CPU，亲和性不好
- 如何提升亲和性？
  - 调度程序尽量保证亲和性 —— 软亲和 
  - 用户进程通过系统调用，主动要求OS分配固定CPU，确保亲和性 —— 硬亲和

#### 方案二：私有就绪队列

- 每个CPU都有一个私有就绪队列
- CPU空闲时调度，从私有就绪队列选一个
- 如何负载均衡？
  - Push策略：负载不均衡，从忙碌CPU的就绪队列中推一些就绪进程到空闲CPU的就绪队列 —— 包工头
  - Pull策略：CPU周期性检查自身负载与其他CPU负载，如果CPU负载低，从忙的拉一些过来 —— 有爱的同事们
- 天然实现亲和性

## 整理

### 进程进入临界区在退出前，状态变化

临界区分为两种

- 系统临界区：此时不可被调度，应迅速执行完当前操作
- I/O等慢速设备：进入后阻塞，应主动让出cpu，进入阻塞态，需要进行一次调度

### 线程进程切换需要进行的操作

- 线程
  - 更新PC
  - 更新栈基址寄存器 —— 因为线程需要用到栈
- 进程

### 满足实时性的调度方法

- 先选抢占式的优先级调度
  - 需要保证实时性的任务设置高优先级就可以
- 实在不行再时间片

### 多级反馈队列的特点

- 优点
  - 资源利用率高
    - 保证大小任务都可以得到较好的实现，同时也不会饥饿
  - 响应速度快
    - 刚来的都先跑一个小时间片
  - 并发度高
- 缺点
  - 系统开销大（但是值得）

### 改变进程优先级的时机

- 进程时间片用完 —— 降低优先级
  - 而不是刚从就绪态转为运行态
- 进程刚完成I/O操作进入队列 —— 提高
  - 因为它是I/O密集型
- 进程长期就绪队列 —— 提高

### 可以处理机调度的时机

- 进程结束
- 进程阻塞（也属于**进入临界区**）
- 系统调用完成返回用户态
- 创建新进程 —— 有时候抢占式需要新进程就调度

### 调度的次数

- 注意从没有进程运行到找到第一个进程运行**也是一次**

