# 第四章 指令系统

## 目录
- [第四章 指令系统](#第四章-指令系统)
  - [目录](#目录)
- [4.1 指令系统](#41-指令系统)
  - [4.1.1 指令集体系结构](#411-指令集体系结构)
  - [4.1.2 指令的基本格式](#412-指令的基本格式)
    - [零地址指令](#零地址指令)
    - [一地址指令](#一地址指令)
    - [二地址指令](#二地址指令)
    - [三地址指令](#三地址指令)
    - [四地址指令](#四地址指令)
  - [4.1.3 定长操作码指令格式](#413-定长操作码指令格式)
  - [4.1.4 扩展操作码指令格式](#414-扩展操作码指令格式)
  - [4.1.5 指令的操作类型](#415-指令的操作类型)
    - [数据传送](#数据传送)
    - [算数和逻辑运算](#算数和逻辑运算)
    - [移位操作](#移位操作)
    - [转移操作](#转移操作)
    - [输入输出操作](#输入输出操作)
  - [考点\&易错点](#考点易错点)
- [4.2 指令的寻址方式](#42-指令的寻址方式)
  - [4.2.1 指令寻址和数据寻址](#421-指令寻址和数据寻址)
    - [指令寻址](#指令寻址)
    - [数据寻址](#数据寻址)
  - [常见的数据寻址方式](#常见的数据寻址方式)

# 4.1 指令系统

## 4.1.1 指令集体系结构

- 机器指令（指令）
- 指令系统，指令集
- 指令集体系结构（ISA）：完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的
- ISA规定的内容**主要包括**：
  - 指令格式，指令寻址方式
  - 操作数的类型，操作数寻址方式，大端/小端
  - 程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式
  - 指令执行过程的控制方式等，程序计数器、条件码等等

## 4.1.2 指令的基本格式

`|操作码字段|地址码字段|`

- **指令字长**：一条指令包含的二进制代码的位数，取决于操作码长度、地址码长度、地址码个数
  - 与机器字长无固定关系
  - 单字长指令、半字长指令、双字长指令
- 定长指令字结构、变长指令字结构
- 主存一般按字节编址，所以指令字长通常为**字节的整数倍**

### 零地址指令

- 不需操作数的指令
- 运算类指令：用于堆栈计算机

### 一地址指令

- 只有目的操作数的单操作数指令
- 隐含约定目的地址的双操作数指令
- 3次访存（取指令1，取操作数1，存结果1）

### 二地址指令

- 常用的算术、逻辑运算指令
- 4次访存（取指令1，取俩操作数2，存结果1）

### 三地址指令

- 第三个地址为结果
- 4次访存（取指令1，取俩操作数2，存结果1）

### 四地址指令

- A4为下一条将要执行指令的地址
- 4次访存

## 4.1.3 定长操作码指令格式

- 定长操作码指令，指令字最高位部分分配**固定**的若干位（定长）表示操作码

- 能表示$2^n$条指令

## 4.1.4 扩展操作码指令格式

- 可变长度操作码
- 扩展操作码：操作码长度随地址码减少而增加
- 设计扩展操作码指令格式时，注意：
  - 不允许短码是长码的前缀
  - 各指令操作码一定不能重复

## 4.1.5 指令的操作类型

### 数据传送

- 寄存器之间
- 内存单元到CPU寄存器
- CPU寄存器到内存单元
- 进栈、出栈

### 算数和逻辑运算

### 移位操作

### 转移操作

- 无条件转移指令 vs 条件转移指令
- 调用指令 vs 转移指令
  - 调用指令必须保存下一条指令的地址，子程序执行完后根据返回地址返回继续执行
  - 转移指令不返回执行

### 输入输出操作

## 考点&易错点

- 指令字长固定 和 操作码长度固定 是两回事
  - 考虑指令字长最小则应该采用扩展编码方式

- 扩展编码指令条数的考虑方式
  - e.g. 假设地址码为6bit，则一条二地址指令会占用$2^6$条一地址指令的空间，一条一地址指令会占用$2^6$条零地址指令的空间
  - 16位定长指令字格式，包含零地址、一地址、二地址3种格式的指令
  - 一地址254条，二地址12条
  - 零地址最多$2^{16}$条，减去就可以$2^{16}-254·2^6-12·2^6·2^6=128$
- 中断隐指令是由硬件实现的，并不是指令系统中存在的指令

# 4.2 指令的寻址方式

**寻址方式**：寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条执行指令的地址的方法。寻址方式分为指令寻址和数据寻址

## 4.2.1 指令寻址和数据寻址

### 指令寻址

- 顺序寻址方式

  PC+1，自动形成下一条指令的地址（若指令字长16bit，则PC自增为(PC)+2

- 跳跃寻址

  转移类指令实现，修改PC值，而下一条指令仍然通过PC给出

  - 跳跃：本条指令给出下条指令地址的计算方式
    - 绝对转移
    - 相对转移
  - 是否跳跃可能受到状态寄存器的控制

### 数据寻址

- **数据寻址**：如何在指令中表示一个操作数的地址，或者怎样计算

- 指令字中设置一个**寻址特征**字段，`|操作码|寻址特征|形式地址A|`
  - **形式地址（A）**结合寻址方式，可以计算操作数在存储器中的真实地址，称为**有效地址（EA）**
    - （A）表示地址A处的数值，A既可以是寄存器编号，也可以是内存地址
  - 立即寻址：形式地址的位数决定了操作数的范围
  - 直接寻址：形式地址的位数决定可寻址范围
  - 寄存器寻址：形式地址的位数决定通用寄存器的最大数量
  - 寄存器间接寻址：寄存器位数决定可寻址的范围

## 常见的数据寻址方式

- 隐含寻址：单地址指令格式隐含约定第二个操作数由累加器（ACC）提供
- 立即寻址：地址字段给出操作数本身，也称立即数，补码表示
- 直接寻址：EA = A
- 间接寻址：操作数地址的地址，EA =（A）；可扩大寻址范围，但是要多次访存
- 寄存器寻址：EA = Ri
- 寄存器间接寻址：EA =（Ri）
- 偏移寻址
  - 相对寻址：EA =（PC）+ A，补码表示
    - 考：跳转范围的计算
  - 基址寻址：EA = (BR) + A，基址寄存器BR（可为专用寄存器也可以为指定的通用寄存器）
  - 变址寻址：EA = (IX) + A
    - 主要用于为多道程序或数据分配存储空间
    - 主要勇敢与处理数组问题
- 堆栈寻址：
  - 堆栈指针（SP）
  - 硬堆栈、软堆栈

## 考点&易错点

- 扩展操作码会提高译码难度
- 考寻址方式：小心问操作数/操作数的地址，问取得的操作数需要（EA）
- 相对地址：以下条指令在内存中首地址为基准位置的偏移量
- 各种寻址方式记忆一下
