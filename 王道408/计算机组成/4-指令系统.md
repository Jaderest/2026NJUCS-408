# 第四章 指令系统

## 目录
- [第四章 指令系统](#第四章-指令系统)
  - [目录](#目录)
- [4.1 指令系统](#41-指令系统)
  - [4.1.1 指令集体系结构](#411-指令集体系结构)
  - [4.1.2 指令的基本格式](#412-指令的基本格式)
    - [零地址指令](#零地址指令)
    - [一地址指令](#一地址指令)
    - [二地址指令](#二地址指令)
    - [三地址指令](#三地址指令)
    - [四地址指令](#四地址指令)
  - [4.1.3 定长操作码指令格式](#413-定长操作码指令格式)
  - [4.1.4 扩展操作码指令格式](#414-扩展操作码指令格式)
  - [4.1.5 指令的操作类型](#415-指令的操作类型)
    - [数据传送](#数据传送)
    - [算数和逻辑运算](#算数和逻辑运算)
    - [移位操作](#移位操作)
    - [转移操作](#转移操作)
    - [输入输出操作](#输入输出操作)
  - [考点\&易错点](#考点易错点)
- [4.2 指令的寻址方式](#42-指令的寻址方式)
  - [4.2.1 指令寻址和数据寻址](#421-指令寻址和数据寻址)
    - [指令寻址](#指令寻址)
    - [数据寻址](#数据寻址)
  - [常见的数据寻址方式](#常见的数据寻址方式)
  - [考点\&易错点](#考点易错点-1)
- [4.3 程序的机器级代码表示（立马学习ICS）](#43-程序的机器级代码表示立马学习ics)
  - [4.3.1 常用汇编指令介绍](#431-常用汇编指令介绍)
    - [相关寄存器](#相关寄存器)
    - [汇编指令格式](#汇编指令格式)
    - [常用指令](#常用指令)
  - [4.3.2 选择语句的机器级表示](#432-选择语句的机器级表示)
  - [4.3.3 循环语句的机器级表示](#433-循环语句的机器级表示)
  - [4.3.4 过程调用的机器级表示](#434-过程调用的机器级表示)

# 4.1 指令系统

## 4.1.1 指令集体系结构

- 机器指令（指令）
- 指令系统，指令集
- 指令集体系结构（ISA）：完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的
- ISA规定的内容**主要包括**：
  - 指令格式，指令寻址方式
  - 操作数的类型，操作数寻址方式，大端/小端
  - 程序可访问的寄存器编号、个数和位数，存储空间的大小和编址方式
  - 指令执行过程的控制方式等，程序计数器、条件码等等

## 4.1.2 指令的基本格式

`|操作码字段|地址码字段|`

- **指令字长**：一条指令包含的二进制代码的位数，取决于操作码长度、地址码长度、地址码个数
  - 与机器字长无固定关系
  - 单字长指令、半字长指令、双字长指令
- 定长指令字结构、变长指令字结构
- 主存一般按字节编址，所以指令字长通常为**字节的整数倍**

### 零地址指令

- 不需操作数的指令
- 运算类指令：用于堆栈计算机

### 一地址指令

- 只有目的操作数的单操作数指令
- 隐含约定目的地址的双操作数指令
- 3次访存（取指令1，取操作数1，存结果1）

### 二地址指令

- 常用的算术、逻辑运算指令
- 4次访存（取指令1，取俩操作数2，存结果1）

### 三地址指令

- 第三个地址为结果
- 4次访存（取指令1，取俩操作数2，存结果1）

### 四地址指令

- A4为下一条将要执行指令的地址
- 4次访存

## 4.1.3 定长操作码指令格式

- 定长操作码指令，指令字最高位部分分配**固定**的若干位（定长）表示操作码

- 能表示$2^n$条指令

## 4.1.4 扩展操作码指令格式

- 可变长度操作码
- 扩展操作码：操作码长度随地址码减少而增加
- 设计扩展操作码指令格式时，注意：
  - 不允许短码是长码的前缀
  - 各指令操作码一定不能重复

## 4.1.5 指令的操作类型

### 数据传送

- 寄存器之间
- 内存单元到CPU寄存器
- CPU寄存器到内存单元
- 进栈、出栈

### 算数和逻辑运算

### 移位操作

### 转移操作

- 无条件转移指令 vs 条件转移指令
- 调用指令 vs 转移指令
  - 调用指令必须保存下一条指令的地址，子程序执行完后根据返回地址返回继续执行
  - 转移指令不返回执行

### 输入输出操作

## 考点&易错点

- 指令字长固定 和 操作码长度固定 是两回事
  - 考虑指令字长最小则应该采用扩展编码方式

- 扩展编码指令条数的考虑方式
  - e.g. 假设地址码为6bit，则一条二地址指令会占用$2^6$条一地址指令的空间，一条一地址指令会占用$2^6$条零地址指令的空间
  - 16位定长指令字格式，包含零地址、一地址、二地址3种格式的指令
  - 一地址254条，二地址12条
  - 零地址最多$2^{16}$条，减去就可以$2^{16}-254·2^6-12·2^6·2^6=128$
- 中断隐指令是由硬件实现的，并不是指令系统中存在的指令

# 4.2 指令的寻址方式

**寻址方式**：寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条执行指令的地址的方法。寻址方式分为指令寻址和数据寻址

## 4.2.1 指令寻址和数据寻址

### 指令寻址

- 顺序寻址方式

  PC+1，自动形成下一条指令的地址（若指令字长16bit，则PC自增为(PC)+2

- 跳跃寻址

  转移类指令实现，修改PC值，而下一条指令仍然通过PC给出

  - 跳跃：本条指令给出下条指令地址的计算方式
    - 绝对转移
    - 相对转移
  - 是否跳跃可能受到状态寄存器的控制

### 数据寻址

- **数据寻址**：如何在指令中表示一个操作数的地址，或者怎样计算

- 指令字中设置一个**寻址特征**字段，`|操作码|寻址特征|形式地址A|`
  - **形式地址（A）**结合寻址方式，可以计算操作数在存储器中的真实地址，称为**有效地址（EA）**
    - （A）表示地址A处的数值，A既可以是寄存器编号，也可以是内存地址
  - 立即寻址：形式地址的位数决定了操作数的范围
  - 直接寻址：形式地址的位数决定可寻址范围
  - 寄存器寻址：形式地址的位数决定通用寄存器的最大数量
  - 寄存器间接寻址：寄存器位数决定可寻址的范围

## 常见的数据寻址方式

- 隐含寻址：单地址指令格式隐含约定第二个操作数由累加器（ACC）提供
- 立即寻址：地址字段给出操作数本身，也称立即数，补码表示
- 直接寻址：EA = A
- 间接寻址：操作数地址的地址，EA =（A）；可扩大寻址范围，但是要多次访存
- 寄存器寻址：EA = Ri
- 寄存器间接寻址：EA =（Ri）
- 偏移寻址
  - 相对寻址：EA =（PC）+ A，补码表示
    - 考：跳转范围的计算
  - 基址寻址：EA = (BR) + A，基址寄存器BR（可为专用寄存器也可以为指定的通用寄存器）
  - 变址寻址：EA = (IX) + A
    - 主要用于为多道程序或数据分配存储空间
    - 主要勇敢与处理数组问题
- 堆栈寻址：
  - 堆栈指针（SP）
  - 硬堆栈、软堆栈

## 考点&易错点

- 扩展操作码会提高译码难度
- 考寻址方式：小心问操作数/操作数的地址，问取得的操作数需要（EA）
- 相对地址：以下条指令在内存中首地址为基准位置的偏移量
- 各种寻址方式记忆一下

# 4.3 程序的机器级代码表示（立马学习ICS）

x86汇编指令为主

## 4.3.1 常用汇编指令介绍

### 相关寄存器

### 汇编指令格式

### 常用指令

- mov：不支持两个操作数同时来自于主存

## 4.3.2 选择语句的机器级表示

### 条件转移指令

- cmp搭配条件转移实现
- je <地址>   #a==b则跳转，应有ZF==1
  - **e**qual
- jne <地址> #a!=b，ZF==0
  - **n**ot equal
- jg <地址>   #a>b，ZF==0&&SF==OF
  - **g**reater
- jge <地址> #a>=b，SF==OF
  - **g**reater **e**qual
- jl <地址>   #a<b，SF!=OF
  - **l**ess
- jle <地址> #a<=b，SF!=OF || ZF==1
  - **l**ess **e**qual

## 4.3.3 循环语句的机器级表示

- 条件转移指令实现循环，4个部分
  1. 循环前初始化
  2. 是否直接跳过循环
  3. 循环主体——以Label标记
  4. 是否继续循环——跳出时也有一个Label
- loop指令，使用**ecx**（指定好了）作为循环计数器
  - loop
  - loopx（x表示nz、z、g、ge、l、le等等）
  - 混个眼熟就行

## 4.3.4 过程调用的机器级表示

### call的两个行为

- IP旧值压栈，保存在函数栈帧顶部
- 设置IP新值，无条件转移至被调用函数的第一条指令

### ret的一个行为

- 函数栈帧顶部找到IP旧值，将其出栈并恢复IP寄存器

### 如何访问栈帧

- 4字节为栈的基本操作单位，32bit；ebp指向当前栈帧底部（高地址）；esp指向当前栈帧顶部（低地址）
  - 注意esp和ebp都在栈帧内，**esp不是空指**

#### push/pop

- push :dog:
  - 先esp-4，再将:dog:压入
  - :dog:可以是立即数、寄存器、主存地址
- pop :horse:
  - 栈顶出栈写入:horse:，再esp+4
  - :horse:可以是寄存器、主存地址

#### mov

- mov指令
  - 直接`sub esp, num`或`add esp, num`，操作esp
  - 然后根据`[esp+offset]`使用mov赋值

### 如何切换栈帧

- call指令：IP压入栈顶（push 旧IP），设置IP新值（jmp func）

- 函数中

  - 切换入栈帧（用enter代替这两条也行）

  ```assembly
  add:
  # 如下两行完成栈帧的切换
  push ebp     #ebp值入栈，并且esp-=4，
  mov ebp,esp  #esp->ebp，这时ebp，esp同时指向新栈帧
  # 注意，此时栈帧底部保存了上一层栈帧的基址
  # 完成这两步后，esp和ebp都指向这个基址
  ```

  - 切换出栈帧（用leave替代这两条）

  ```assembly
  mov esp,ebp   #ebp指向基址，将esp直接赋值过来，丢弃栈帧
  pop ebp       #esp所指出栈，写入寄存器ebp，esp+=4
  ```

- call由调用者使用，ret由被调用者使用
- 调用者行为
  1. ……
  2. 执行call
  3. ……
- 被调用者行为
  1. 保存栈帧
  2. ……
  3. 恢复栈帧
  4. ret

### 如何传递调用参数、返回值

- 一个函数栈帧的内容

```c
int caller() {
    int tmp1 = 125;
    int tmp2 = 80;
    int sum = add(tmp1, tmp2); // 会与汇编一一对应
    return sum;
}
int add(int x, int y) {
    return x+y;
}
```

```
# 由上到下表示高地址->低地址
--------------------------caller栈帧
上一层栈帧基址  <- ebp
----------------若干局部变量
sum           <- ebp-4
tmp2
tmp1          <- ebp-12
----------------空闲区域
……（空闲未使用，可能不存在）
----------------调用参数
y			  <- 新ebp+12
x             <- 新ebp+8
----------------
IP（由call保存）
--------------------------add栈帧
该层栈帧基址    <- 新ebp
----------------
……
--------------------------
```

- 数据对齐要求
  - 当前函数栈帧无所谓，4B、8B...都可以
  - 但是调用新函数时，需要凑齐到16B的整数倍，例如这里的caller栈帧，中间凑了一个未使用的空闲区域

- 读取参数
  - [ebp+offset]
- 传递返回值
  - 常用eax（只有一个返回值）

### 函数栈帧（补充版本）

```
IP(返回地址)
---------------------------
上一层栈帧基址
-------------
若干局部变量
-------------
未使用区域
-------------
部分寄存器值    # eax、edx、ecx入栈保存，防止中间结果被破坏
			  # 不一定存在，如果寄存器值不是中间结果则不用
-------------
若干调用参数
-------------
IP（返回地址）
---------------------------
```

