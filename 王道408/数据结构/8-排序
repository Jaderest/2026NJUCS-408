# 第八章 排序

## 目录
- [第八章 排序](#第八章-排序)
  - [目录](#目录)
- [8.1 排序基本概念](#81-排序基本概念)
- [8.2 插入排序](#82-插入排序)
  - [8.2.1 直接插入排序](#821-直接插入排序)
  - [8.2.2 折半插入排序](#822-折半插入排序)
  - [8.2.3 希尔排序](#823-希尔排序)
  - [小技巧](#小技巧)
- [8.x 各种排序过程中数据排列情况的特征](#8x-各种排序过程中数据排列情况的特征)

# 8.1 排序基本概念

- 排序：按关键字有序
- 算法的稳定性
- 分类
  - 内部排序
  - 外部排序 —— 涉及到外存
- 易错：**拓扑排序不是这里的排序算法**

# 8.2 插入排序

基本思想：待排序的记录按关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成

## 8.2.1 直接插入排序

- 哨兵

  ```c
  void InsertSort (ElemType A[], int n) {
      int i, j;
      for (i=2; i<=n; i++) {
          if (A[i] < A[i-1]) {
              A[0] = A[i]; // A[0]不存放元素
              for (j=i-1; A[0]<A[j]; --j) {
                  A[j+1]=A[j]; //向后挪位置，直到找到要插入/哨兵
              }
              A[j+1] = A[0];
          }
      }
  }
  ```

- 稳定的算法
- 适用于顺序存储/链式存储的线性表，无须移动元素
- n个元素最坏比较次数：$\frac{n(n-1)}{2}$
  - 不要考虑哨兵的比较 —— 哨兵是实现方法加的，这个只是问逻辑上的比较次数

## 8.2.2 折半插入排序

将查找过程换为折半查找

```c
void InsertSort (ElemType A[], int n) {
    int i, j, low, high, mid;
    for (i=2; i<=n; i++) { // 处理A[2]~A[n]
        A[0]=A[i];  // 暂存，因为最后平移需要从A[i]开始
        low = 1; high = i-1; // 在处理好的序列中可以进行折半查找
        while(low <= high) {
            mid = (low + high) / 2;
            if (A[mid] > A[0]) high = mid - 1;
            // 保证了定位到一组相同数中最右边的位置 -> 保证了稳定性
            else low = mid + 1; // <= 
        }
        // 目标位置为high
        for (j = i-1; j >= high+1; --j) {
            A[j+1] = A[j];
        }
        A[high+1] = A[0];
    }
}
```

-  稳定
- 仅顺序存储

## 8.2.3 希尔排序

缩小**增量**排序

- 目前没有特别好的增量序列
- 取小于n的增量d1，表中记录分为d1组，各组内直接插排
  - d2 < d1，重复
  - 直到dt = 1

效率分析

- 空间复杂度$O(1)$
- 在特定范围内，时间复杂度约为$O(n^{1.3})$
- 最坏，$O(n^2)$

不稳定

仅适用于顺序存储

## 小技巧

- 判断直接插排比较次数：考虑逆序数，逆序数越小，则直接插排比较次数越小

# 8.x 各种排序过程中数据排列情况的特征
