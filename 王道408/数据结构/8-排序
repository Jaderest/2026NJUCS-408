# 第八章 排序

## 目录
- [第八章 排序](#第八章-排序)
  - [目录](#目录)
- [8.1 排序基本概念](#81-排序基本概念)
- [8.2 插入排序](#82-插入排序)
  - [8.2.1 直接插入排序](#821-直接插入排序)
  - [8.2.2 折半插入排序](#822-折半插入排序)
  - [8.2.3 希尔排序](#823-希尔排序)
  - [小技巧](#小技巧)
- [8.3 交换排序](#83-交换排序)
  - [8.3.1 冒泡排序](#831-冒泡排序)
  - [8.3.2 快速排序](#832-快速排序)
  - [常见考点及做法](#常见考点及做法)

# 8.1 排序基本概念

- 排序：按关键字有序
- 算法的稳定性
- 分类
  - 内部排序
  - 外部排序 —— 涉及到外存
- 易错：**拓扑排序不是这里的排序算法**

# 8.2 插入排序

基本思想：待排序的记录按关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成

## 8.2.1 直接插入排序

- 哨兵

  ```c
  void InsertSort (ElemType A[], int n) {
      int i, j;
      for (i=2; i<=n; i++) {
          if (A[i] < A[i-1]) {
              A[0] = A[i]; // A[0]不存放元素
              for (j=i-1; A[0]<A[j]; --j) {
                  A[j+1]=A[j]; //向后挪位置，直到找到要插入/哨兵
              }
              A[j+1] = A[0];
          }
      }
  }
  ```

- 稳定的算法
- 适用于顺序存储/链式存储的线性表，无须移动元素
- n个元素最坏比较次数：$\frac{n(n-1)}{2}$
  - 不要考虑哨兵的比较 —— 哨兵是实现方法加的，这个只是问逻辑上的比较次数

## 8.2.2 折半插入排序

将查找过程换为折半查找

```c
void InsertSort (ElemType A[], int n) {
    int i, j, low, high, mid;
    for (i=2; i<=n; i++) { // 处理A[2]~A[n]
        A[0]=A[i];  // 暂存，因为最后平移需要从A[i]开始
        low = 1; high = i-1; // 在处理好的序列中可以进行折半查找
        while(low <= high) {
            mid = (low + high) / 2;
            if (A[mid] > A[0]) high = mid - 1;
            // 保证了定位到一组相同数中最右边的位置 -> 保证了稳定性
            else low = mid + 1; // <= 
        }
        // 目标位置为high
        for (j = i-1; j >= high+1; --j) {
            A[j+1] = A[j];
        }
        A[high+1] = A[0];
    }
}
```

-  稳定
- 仅顺序存储

## 8.2.3 希尔排序

缩小**增量**排序

- 目前没有特别好的增量序列
- 取小于n的增量d1，表中记录分为d1组，各组内直接插排
  - d2 < d1，重复
  - 直到dt = 1

效率分析

- 空间复杂度$O(1)$
- 在特定范围内，时间复杂度约为$O(n^{1.3})$
- 最坏，$O(n^2)$

不稳定

仅适用于顺序存储

## 小技巧

- 判断直接插排比较次数：考虑逆序数，逆序数越小，则直接插排比较次数越小

# 8.3 交换排序

交换：根据序列中两个元素关键字的比较结果来对换这个两个记录在序列中的位置

- 比一下交换一次（有序就不交换）

## 8.3.1 冒泡排序

基本思想：

- 从后往前（or从前往后）两两比较相邻元素位置（即5和4；4和3；3和2；2和1）
- 若逆序，则交换它们，直到序列比较完。称它为第一趟冒泡
- 从后往前->最小的元素漂浮至第一位；从前往后->最大的元素到达最后一个位置
- n-1趟冒泡将所有元素排好序

```c
void BubbleSort(ElemType A[], int n) {
    for (int i = 0; i<n-1; i++) {
        bool flag = false;
        for (int j = n-1; j > i; j--) {
            if (A[j-1] > A[j]) {
                swap (A[j-1], A[j]); // 封装的swap函数
                flag = true;
            }
        }
        if (flag == false) { // 如果没发生交换，则表已经有序
            return;
        }
    }
}
```

性能分析：

- 空间效率：O(1)
- 时间效率
  - 最好情况，扫一趟有序，比较n-1次，移动0次，O(n)
  - 最坏情况，n-1趟排序，i趟进行n-i次关键字比较，每次比较后都移动元素3次以交换位置
    - 比较次数n(n-1)/2; 移动次数3n(n-1)/2
    - 时间复杂度O(n2), 平均时间复杂度O(n^2)



## 8.3.2 快速排序

基本思想：

- pivot -> L[k] （L[1...n]）
  - 同时`L[1...k-1] < pivot`; `L[k+1...n] > pivot`
  - 称作一次划分 —— 算法题
- 对左右两个子表递归重复上述过程
- 一趟快排：是交替搜索和交换的过程

```c
void QuickSort(ElemType A[], int low, int high) {
    if (low < high) {
        int pivot_index = Partition(A, low, high);  // 进行划分，这里默认使用首元素作为pivot
        QuickSort(A, low, pivot_index-1);
        QuickSOrt(A, pivot_index-1, high);
    }
}

int Partition(ElemType A[], int low, int high) {
    ElemType pivot = A[low];
    while(low < high) {
    	while (low < high && A[high] >= pivot) --high; // 高的跳过
        A[low] = A[high]; // 比pivot小的移到左端
        while (low < high && A[low] <= pivot) ++low;
        A[high] = A[low];
    }
    A[low] = pivot;
    return low;
}
```

性能分析：

- 容量与递归调用的最大层数一致
  - 最好$O(\log_2n)$
  - 最坏n-1次递归，O(n)
  - 平均情况下栈深度$O(\log_2n)$
- 时间效率
  - 最坏O(n2)
  - 最好$O(n\log_2n)$
- 稳定性：不稳定 —— 怎么调都不稳定

## 常见考点及做法

- 冒泡排序 —— 问趟数
  - 首先看题目说趟数包不包含无交换的最后一趟
  - 然后老实手排
- 问一个序列可不可能是n趟快排后的序列
  - n趟 -> 找n个pivot
  - pivot只要满足左边都比pivot 小（大）且右边的都比pivot 大（小）即可
  - 小技巧：先看最左边是不是最小和最右边是不是最大，是就可以算一个pivot
- 问快排中移动记录次数最多 —— 老实算别偷懒
- 问快排最好情况比较次数，例如长度8的最好情况
  - 第一次分为3、4，比较7次（分出来的所有都需要与pivot进行一次比较才能确定）
  - 3分为1和1，不用再分，比2次
  - 4分为1和2，比3次
  - 2分为1，比1次
  - 共7+2+3+1=13次











todo：8.x 各种排序过程中数据排列情况的特征
