# 第六章 图

## 目录
- [第六章 图](#第六章-图)
  - [目录](#目录)
- [6.1 图的概念](#61-图的概念)
    - [连通、连通图和连通分量；强连通图、强连通分量](#连通连通图和连通分量强连通图强连通分量)
    - [考点\&易错点](#考点易错点)
- [6.2 图的存储及基本应用](#62-图的存储及基本应用)
  - [6.2.1 邻接矩阵法](#621-邻接矩阵法)
  - [6.2.2 邻接表法](#622-邻接表法)
  - [6.2.3 十字链表](#623-十字链表)
  - [6.2.4 邻接多重表](#624-邻接多重表)
- [6.3 图的遍历](#63-图的遍历)
  - [6.3.1 BFS](#631-bfs)
    - [性能分析](#性能分析)
    - [BFS求解单源最短路径](#bfs求解单源最短路径)
    - [BF生成树](#bf生成树)
  - [6.3.2 DFS](#632-dfs)
    - [性能分析](#性能分析-1)
    - [深度优先生成树和生成森林](#深度优先生成树和生成森林)
  - [6.3.3 图的遍历和图的连通性](#633-图的遍历和图的连通性)
  - [概念补充](#概念补充)
  - [易错点](#易错点)
- [6.4 图的应用](#64-图的应用)
  - [6.4.1 最小生成树](#641-最小生成树)
    - [Prim算法](#prim算法)
    - [Kruskal算法](#kruskal算法)
  - [6.4.2 最短路径](#642-最短路径)
    - [Dijkstra单源最短路径](#dijkstra单源最短路径)
    - [Floyd各顶点最短路径](#floyd各顶点最短路径)
  - [6.4.3 有向无环图](#643-有向无环图)
  - [6.4.4 拓扑排序](#644-拓扑排序)
    - [基于栈实现拓扑排序](#基于栈实现拓扑排序)
    - [逆拓扑排序](#逆拓扑排序)
    - [基于DFS实现逆拓扑排序](#基于dfs实现逆拓扑排序)
    - [性质](#性质)
  - [6.4.5 关键路径](#645-关键路径)
    - [关键路径性质](#关键路径性质)
    - [几个参量定义](#几个参量定义)
    - [思路](#思路)
    - [特性](#特性)
  - [考点\&易错点](#考点易错点-1)

# 6.1 图的概念

### 连通、连通图和连通分量；强连通图、强连通分量

- 顶点v和顶点w连通：v到w有路径
- 图G中任意两点都是连通的，称图G为连通图，否则称非连通图
- 无向图 —— 连通性
- 有向图 —— 强连通性
- **极大/极小连通子图**
  - 极大：连通+尽可能多的顶点和边
  - 极小：连通+边数最少

### 考点&易错点

- 强连通有向图中任何顶点到其他所有顶点都有路径
  - 但未必有弧
  - 弧：两个顶点的有序对 —— 直接连边
- 有向完全图：每点到每点都有弧
- 有向图中
  - 顶点的度 = 入度 + 出度
- G中含有7个顶点，保证G在任何情况下都是连通，则需要边数最少为？
  - 16
  - 任何情况：分配边的方式，所以6个构成完全图+一条边连到第7个顶点上

# 6.2 图的存储及基本应用

## 6.2.1 邻接矩阵法

特点

- 表示方法唯一

- 无向图邻接矩阵必是对称矩阵 -> 对称矩阵的存储
- 稠密图适合邻接矩阵
- 邻接矩阵$A$，有$A^n$的元素$A^n[i][j]$表示 i 到 j 经过n条边的路径的数目

## 6.2.2 邻接表法

特点

- 对稀疏图极大节省空间
- 邻接表表示并不唯一，各边顶点链接次序任意（取决于建表算法和输入次序）

## 6.2.3 十字链表

**有向图**

两种结点

- 弧结点，5个域
  - tailvex、headvex：存放弧尾弧头顶点的编号
  - 头链域hlink：指向弧头相同的下一条弧
  - 尾链域tlink：弧尾相同的下一条弧
  - info：权值
- 顶点结点，3个域
  - data
  - firstin
  - firstout

性能

- 找入边、出边非常方便

## 6.2.4 邻接多重表

存无向图

便于插入删除

# 6.3 图的遍历

## 6.3.1 BFS

### 性能分析

- 空间复杂度：辅助队列Q；最坏情况空间复杂度$O(|V|)$
- 时间复杂度
  - 邻接表：每个顶点入队一次$O(|V|)$；每条边访问一次$O(|E|)$，得到$O(|V|+|E|)$
  - 邻接矩阵：查找每个点邻接点$O(|V|)$，总时间复杂度$O(|V|^2)$

### BFS求解单源最短路径

G = (V, E) 为**非带权图**，顶点u到v的最短路径$d(u,v)$定义为u到v任何路径中**最少边数**

- BFS求单源最短路径如下

```c
void BFS_MIN_Distance(Graph G, int u) {
    for (int i=0; i<G.vexnum; ++i) {
        d[i] = INF;
    }
    visited[u] = true;
    d[u] = 0;
    EnQueue(Q, u); // 空队列Q，将u入队
    while(!isEmpty(Q)) {
        DeQueue(Q, u);
        for (w=FirstNeighbor(G,u); w>=0; w=NextNeighbot(G,u,w)) {
            if (!visited[w]) {
                visited[w] = true;
                d[w] = d[u] + 1; // w 为 u 的一个后继
                EnQueue(Q, w);
            }
        }
    }
}
```

### BF生成树

BFS中，得到一棵遍历树

- 同一图邻接矩阵表示唯一 -> 广度优先生成树唯一
- 邻接表存储表示不唯一 -> 广度优先生成树不唯一

## 6.3.2 DFS

### 性能分析

- 空间复杂度：递归工作栈，$O(|V|)$
- 时间复杂度
  - 邻接表：$O(|V|+|E|)$
  - 邻接矩阵：$O(|V|^2)$

### 深度优先生成树和生成森林

连通图才有深度优先生成树，否则是深度优先生成森林

## 6.3.3 图的遍历和图的连通性

无向图：外部循环BFS/DFS的次数 = 图连通分量数

有向图：连通子图分为强连通分量、非强连通分量

​	非强连通分量调用BFS或DFS不一定能访问到该子图 所有顶点

## 概念补充

强连通图弱连通图——有向图中的概念

- 强连通：一点到任一点都有有向路径
- 弱连通：不是强连通 + 有向边改无向发现连通了

连通分量，连通子图——无向图中概念

- 连通子图：连通就行
- 连通分量：极大连通子图

## 易错点

- 看清无向图/有向图
- 画图画清楚，别漏边了
- 画图不一定要先把点标出来，按照有的边一个个把点描出来可能看得更清楚一些

# 6.4 图的应用

## 6.4.1 最小生成树

### Prim算法

带权无向图——有向图不可以

```c
void Prim(G, T) {
    T = \empty;  // T = (U, E_T)，U为顶点集，E_T为边集
    U = {w};
    // 若树中不含全部顶点，加入一个新顶点且连边权值最小
    while ({V - U} != \empty) {
    	E_T = E_T 并 {u, v};
    	U = U 并 {v};
    }
}
```

- 时间复杂度 $O(|V|^2)$
- 稠密图

### Kruskal算法

```c
void Kruskal(V, T) { // G = (V, E)
    T = V; // 初始化树，只含顶点
    numS = n; // 标记连通分量数
    while(numS > 1) {
        E中取出权值最小边(v, u);
        if(v和u属于不同连通分量) {
            T = T 并 {(v, u)};
            numS--;
        }
    }
}
```

- 最坏情况扫描$|E|$条边
- 使用堆存放边集合，$O(\log_2|E|)$选权值最小边
- 并查集判断两顶点是否同一集合 ，$O(\alpha(|V|))$，常数
- $O(|E|\log(|E|))$

## 6.4.2 最短路径

### Dijkstra单源最短路径

带权有向图&带权无向图

- 算法过程

  - 选一个源点作为初始点

  - 不断加点（为当前距离最短的点）并更新点边连接的所有点的最短距离

- 不适用于负权值（会无限更新最短距离）

- $O(|V|^2)$

### Floyd各顶点最短路径

$A^{(k)}[i][j]=\min\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\}$

- $O(|V|^3)$

## 6.4.3 有向无环图

DAG图

- 构建二叉树描述表达式
- 消除公共表达式，变为有向无环图描述表达式

## 6.4.4 拓扑排序

- AOV网 —— DAG图
- 拓扑排序定义
  - 每个顶点只出现一次，A在B前，则不存在B到A的路径
  - or 若存在A到B的路径，则A在B前面

### 基于栈实现拓扑排序

- 从AOV网中选一个没有前驱的顶点输出
- 删除顶点出发的有向边
- 重复1、2直到网为空或网中不存在无前驱的顶点
  - 若还有顶点（但是有前驱）：有向图中必然存在环 —— 判断环
- 使用栈来实现拓扑排序

```c
bool TopologicalSort(Graph G) {
    InitStack(S); // 初始化栈，存储入度为0的顶点
    int i;
    for (i=0; i<G.vexnum; i++) {
        if (indegree[i]==0) {
            Push(S, i);
        }
    }
    int count = 0; // 记录输出顶点数
    while(!isEmpty(S)) {
        Pop(S, i);  // 栈顶出栈
        print(i);
        count++;
        for (p=G.vertices[i].firstarc; p; p=p->nextarc) {
            // 所有i指向顶点入度-1，为0则入栈
            v = p->adjvex;
            indegree[v]--;
            if(indegree[v] == 0) {
                Push(S, v);
            }
        }
    }
    if (count < G.vexnum) return false; // 有回路
    else return true;
}
```

- 效率分析
  - 邻接表删点还需删除它起点的边：$O(|V|+|E|)$
  - 邻接矩阵：$O(|V|^2)$，每个点$O(|V|)$遍历它的出边，找到对应顶点减去入度

### 逆拓扑排序

上述算法入度改为出度，如果采用邻接表好像会非常低效！使用逆邻接表

### 基于DFS实现逆拓扑排序

- 借用DFS的栈

  ```c
  void DFSTraverse(Graph G) {
      for (v=0; v<G.vexnum; ++v) {
          visited[v] = false;
      }
      for (v=0; v<G.vexnum; ++v) {
          if (!visited[v]) DFS(G, v);
      }
  }
  void DFS(Graph G, int v) {
      visited[v] = true;
      for (w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G, v)) {
          if (!visited[w]) {
              DFS(G, w);
          }
      }
      print(v); // 退栈前输出
  }
  ```

- 如何判断回路

### 性质

- 拓扑排序、逆拓扑排序可能不唯一

- 若图中有环，则不存在拓扑/逆拓扑排序 —— 判断环使用拓扑排序

## 6.4.5 关键路径

AOE网：边表示活动的网，AOE网(Action On Edge?)

- 仅有一个入度为0的顶点——开始顶点（源点）
- 仅有一个出度为0的顶点——结束顶点（汇点）

### 关键路径性质

- 关键路径：源点到汇点所有路径
- 关键活动
- 找到关键活动，即找到了关键路径，可以得出最短完成时间

### 几个参量定义

- 事件vk最早发生时间$v_e(k)$：决定顶点vk开始的活动能开工的最早时间
  - 引入活动ai最早开始时间$e(i)$：该活动弧的起点表示的时间的最早发生时间
- 事件vk最迟$v_l(k)$：不推迟整个工程的情况下，保证后继vj在其最迟发生时间$v_l(j)$能够发生时，该事件最迟必须发生的事件
  - ai最迟发生时间 $l(i)$
  - 从汇点（最后的点）来的递推公式
    - vl(汇点) = ve(汇点)
    - 然后往前推
- 时间余量$d(i)=l(i)-e(i)$

### 思路

1. 求ve
   - 按拓扑排序序列，依次求各顶点ve(k)
   - ve(源点)=0
   - ve(k) = max{ve(j) + Weight(vj, vk)}，vj为vk任意前驱
2. vl
   - 逆拓扑序列，vl
   - vl(汇点)=ve(汇点)
   - vl(k) = min{vl(j) - Weight(vk, vj)}，vj为vk任意后继
3. e
   - 等于起点的 ve
4. l
   - 等于终点的 vl-l(i)
5. 求出d，所有d为0的即为关键结点

### 特性

- 关键活动耗时增加，整个工期增长
- 关键活动耗时缩短，可缩短整个工程工期
- 缩短到一定程度，关键活动可能变为非关键活动
- 可能**多条关键路径**

## 考点&易错点

- 最短路径一定是简单路径
  - 简单路径：路径上顶点不重复出现
- Dijkstra可以求任意两顶点最短路径
  - 可以求，**不能说**不适合
- Floyd允许负权边，不允许负权环
- Dijkstra算法执行中，只可能修改从源点到V-S某个顶点的最短路径
  - 其他说法都不对，比如修改2->4最短路径
- 强连通分量 -> 有向图中具有回路
  - 有回路 -> 回路构成一个强连通分量

- **最小生成树的代价**：最小生成树的权值之和

- 拓扑排序并不要求图连通

- AOE中区别**事件**和**弧**
- DAG表示表达式，若出现x+y, x，那么这个x是需要重复利用的