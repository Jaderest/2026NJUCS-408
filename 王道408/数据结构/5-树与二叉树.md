# 第五章 树与二叉树

## 目录
- [第五章 树与二叉树](#第五章-树与二叉树)
  - [目录](#目录)
- [5.1 树的基本概念](#51-树的基本概念)
- [5.2 二叉树的基本概念](#52-二叉树的基本概念)
  - [特殊二叉树](#特殊二叉树)
  - [二叉树存储结构](#二叉树存储结构)
    - [顺序存储](#顺序存储)
  - [一些易错点](#一些易错点)
- [5.3 树的遍历与线索化](#53-树的遍历与线索化)
    - [后序线索二叉树中线索的指向](#后序线索二叉树中线索的指向)
    - [一些关于NLR、LNR、LRN性质的分析](#一些关于nlrlnrlrn性质的分析)
    - [先序序列为abcd的不同二叉树个数为](#先序序列为abcd的不同二叉树个数为)
    - [算法整理](#算法整理)
- [5.4 树、森林](#54-树森林)
  - [5.4.2 树、森林与二叉树的转换](#542-树森林与二叉树的转换)
    - [孩子兄弟表示法](#孩子兄弟表示法)
  - [5.4.3 树和森林的遍历](#543-树和森林的遍历)
    - [树的遍历](#树的遍历)
    - [森林的遍历](#森林的遍历)
    - [一些名词补充\&可能方向](#一些名词补充可能方向)

# 5.1 树的基本概念

- 树的度：树中结点的最大度数
- 树的路径长度：从根节点到所有叶结点的路径长度之和 —— 注意区别霍夫曼树
- n个结点的树，度为n-1
- 关于n个结点、度为m、分析树的高度h最小最大
  - 或度为m，高为h，分析结点n的最大最小
- 一点小技巧
  - 森林中每颗树让 n-m 增大1，例如25个结点、15条边的森林中有 25 - 15 = 10棵树
  - 分析树上叶结点的个数
    - 每个度为m的结点让叶结点增多m-1；基础叶节点个数为1
    - 于是m叉树中，N1个度数为1的结点、N2个度2、...、Nm个度m，叶结点个数为$\Sigma^m_{i=2}(i-1)Ni+1$

# 5.2 二叉树的基本概念

## 特殊二叉树

- 满二叉树
- 完全二叉树
- 二叉排序树
- 平衡二叉树
- 正则二叉树：结点的子结点树为0或2

## 二叉树存储结构

### 顺序存储

- 完全二叉树
- 一般二叉树
  - **如果必定会占到h层，为了保证它的任意性，它所需的空间和h层完全二叉树相同**
  - 例如5层有10个结点的二叉树：我们不能限定它的形状，所以它在5层的结点分布是任意的；需要和5层完全二叉树相同的空间

## 一些易错点

- 124个叶节点的完全二叉树最多多少个结点？
  - 小心一个叶结点若改为有一个子结点，**则总叶结点个数并不改变**，所以算最多结点时需要注意是否能加这一个子节点

- 遇到问树的性质的，多考虑一下根结点

# 5.3 树的遍历与线索化

### 后序线索二叉树中线索的指向

后序线索二叉树中找结点的后继，分为三种情况：

1. 若结点x是二叉树的根，则后继为空
2. 若结点x是右孩子/x是左孩子且其父结点无右子树 -> 后继为父结点
3. x是左孩子，父结点有右子树，则其后继为双亲右子树后续遍历列出的第一个结点

![后序线索二叉树](./5-pic/后序线索二叉树.png)

- 如图中B，B的后继无法通过链域找到，B的后继是F
- **后序线索树的遍历需要栈的支持**

### 一些关于NLR、LNR、LRN性质的分析

- 先序序列与中序序列完全相同：NLR=LNR -> L为空，每个结点都只有右子树或没有
- 后序序列与中序序列完全相同：LNR=LRN -> R为空
- 前序与后序序列中若出现
  - 前序...p...q...；后序...q...p...   
  - 由<u>N</u> <u>LR</u>和<u>LR</u> <u>N</u>可知p必定是q的祖先，因为只有为祖先后代关系，二者顺序才会倒过来

### 先序序列为abcd的不同二叉树个数为

- 首先了解前序遍历和中序遍历的过程：前序遍历相当于入栈次序、中序遍历相当于出栈次序
- 所以给定入栈次序的长度，出栈次序的个数也确定了
- 出栈次序=中序次序 + 入栈次序 = 唯一确定二叉树
- **出栈次序数量 = 二叉树个数**
- 入栈长n，二叉树个数$\frac{1}{n+1}C_{2n}^{n}$，卡特兰树

### 算法整理

- 中序遍历为递增序列的二叉树T，若想构造一个中序遍历为递减序列的二叉树T'
  - 只需要交换所有结点的左右子树
  - 那么我们实现这种算法：采用后序遍历，先处理完所有左右子树，然后再处理这个根，递归往上走

- 求WPL：树上所有叶结点的带权路径之和
  - 中间结点不用管
  - 只要管叶结点即可

- 判断一个顺序存储的二叉树是否是搜索二叉树

  ```c
  // val记录中序遍历中已遍历结点的最大值，初值为一个负整数。若当前遍历的结点值小于等于val，则返回false，否则更新val值
  bool judge(SqBiTree bt, int k, int *val) { 
      // 初始调用k为0，从根出发
      if (k < bt.ElemNum && bt.SqBiTNode[k] != -1) {
          if(!judge(bt, 2*k+1, val)) return false;
          if(bt.SqBiTNode[k]<=*val) return false;
          *val = bt.SqBiTNode[k];
          if(!judge(bt, 2*k+2, val)) return false;
      }
      return false;
  }
  ```

# 5.4 树、森林

## 5.4.2 树、森林与二叉树的转换

### 孩子兄弟表示法

一个结点中两个指针域保存第一个孩子和右兄弟的指针

## 5.4.3 树和森林的遍历

### 树的遍历

先根遍历

- 访问根结点
- 再依次遍历根结点的每颗子树（遍历子树也采用先根后子树）
- 遍历序列 = 相应二叉树的先序序列

后根遍历

- 依次遍历根结点每颗子树，遍历子树遵循先子树后根
- 访问根结点
- 遍历序列 = 相应二叉树中序序列

### 森林的遍历

先序遍历森林

中序遍历森林（有时候也叫森林的后序遍历，因为根确实是最后才访问）

### 一些名词补充&可能方向

**非终端结点、分支结点：非叶结点**

- 每个非终端结点都有子结点

- 在转换到二叉树之后，子结点里最后一个兄弟的右指针域必定为空

- 一棵树中n个非终端结点 -> 转换成二叉树后有n+1个结点无右孩子

  - n个非终端->n组孩子，每组1个无右指针  n
  - 根结点转换后也无右指针                           +1
  - 得到 n+1

- 例：王道数据结构`P176 T16`，树有2011个结点、叶结点有116个，树对应二叉树中无右孩子结点个数为<u>2011-116+1=1896</u>

  - 法1即上述分析

  - 法2使用特殊情况

    ![5-4-T16](./7-pic/5-4-T16.png)

**树的孩子兄弟表示法中一些说法的等价转换：**

- *结点左指针域为空 = 结点没有孩子 = 结点为叶节点*（**这个好像很重要**）
- 结点右指针域为空 = 结点为最后一个兄弟
- 例题：某树孩子兄弟链表示中，有6个空左指针、7个空右指针，并且5个结点左、右指针域都为空。分析树中叶结点个数
  - 6空左指针 -> 6个叶结点
