# 第二章 线性表

## 目录
- [第二章 线性表](#第二章-线性表)
  - [目录](#目录)
- [2.1 线性表的定义](#21-线性表的定义)
  - [2.1.1 定义](#211-定义)
  - [2.1.2 基本操作](#212-基本操作)
- [2.2 线性表的顺序表示](#22-线性表的顺序表示)
  - [2.2.1 定义](#221-定义)
  - [2.2.2 基本操作](#222-基本操作)
    - [静态分配](#静态分配)
    - [动态分配](#动态分配)
    - [一个大题整理](#一个大题整理)
- [2.3 线性表链式表示](#23-线性表链式表示)
  - [2.3.1 单链表\&基本操作](#231-单链表基本操作)
    - [不带头节点](#不带头节点)
    - [带头节点](#带头节点)
    - [循环单链表](#循环单链表)
  - [2.3.3 算法题需要注意](#233-算法题需要注意)

# 2.1 线性表的定义

## 2.1.1 定义

- **相同**数据类型，n个数据元素**有限序列**
  - 表头元素、表尾元素、前驱、后继

## 2.1.2 基本操作



# 2.2 线性表的顺序表示

也称顺序表，物理位置连续

## 2.2.1 定义

- 逻辑顺序与物理顺序相同
- 主要优点
  - 随机访问
  - 存储密度高
- 缺点
  - 插入删除需移动大量元素
  - 连续存储空间，不够灵活

## 2.2.2 基本操作

在初始化前**已声明完成**

### 静态分配

- 静态“数组”存放元素

  ```c
  #define MaxSize 100
  typedef struct {
      ElemType data[MaxSize];
      int length;
  } SqList;
  
  // 初始化
  void InitList(SqList &L) {
      // 不用再次分配空间，因为声明时已分配
      L.length = 0;
  }
  
  // 插入：位置i插入指定元素e
  bool ListInsert(SqList &L, int i, ElemType e) {
      // 为了**健壮性**，加一个i范围的判断 & 存储满的判断
      // i 属于 [1, length+1] （i从1开始，数组从0开始）
      if (i < 1 || i > L.length+1) 
          return false;
      if (L.length >= MaxSize)
          return false;
      
      // 后移、插入、长度+1
      for (int j = L.length; j >= i; j--) {
          L.data[j] = L.data[j-1]; //问题规模n=L.length
      }
      L.data[i-1] = e;
      // 最好情况: i=n+1，0次
      // 最坏情况: i=1，n次
      // 平均情况: 1/(n+1) * (0+1+...+n) = n/2
      L.length++;
      return true;
  }
  
  // 删除：位置i删除给e
  bool ListDelete(SqList &L, int i, ElemType e) {
      if (i < 1 || i > L.length)
          return false;
      e = L.data[i-1];
      for (int j = i;  j < L.length; j++) {
          L.data[j-1] = L.data[j]; // 问题规模n=L.Length
      }
      // 最好情况：i=n，0次
      // 最坏情况：i=1，n-1次
      // 平均情况：1/n * (0+1+...+n-1) = (n-1)/2
      L.length--;
      return true;
  }
  
  // 按位查找
  ElemType GetElem(SqList &L, int i) {
      // 健壮性：判断i的范围
      
      // 随机访问
      return L.data[i-1];
  }
  
  // 按值查找，返回位序（由1开始的序号）
  // 最好情况1次；最坏情况n次
  // 平均 O(n)
  int LocateElem (SqList L, ElemType e) {
      int i;
      for (i = 0; i<L.length; i++) {
          if (L.data[i]==e) { // 小心结构类型的比较
              				// 按分量来比较
              return i+1;
          }
      }
      return 0;
  }
  ```

  

### 动态分配

```c
#include <stdlib.h>
#define InitSize 10
typedef struct {
    ElemType *data;
    int MaxSize;
    int length;
} SeqList;

// 初始化
void InitList(SeqList &L) {
    L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);
    L.length = 0;
    L.MaxSize = InitSize;
}

void IncreaseSize(SeqList &L, int len) {
	// 申请新区域
    ElemType *p = L.data;
    // 数据复制
    L.data = (ElemType *)malloc(~~~);
    for (int i = 0; i < L.length; i++) {
        L.data[i] = p[i];
    }
    L.MaxSize = L.MaxSize + len;
    // 释放原有内存空间
    free(p);
}
```

### 一个大题整理

**题面**：整数序列、寻找主元素，若存在则输出，若不存在则输出-1

**标答**（经典必背）：

1. 选取候选的主元素。依次扫描数组中每个整数，将遇到的第一个整数Num保存到c中，记录Num出现次数记为1；若遇到的下一个整数仍等于Num，则计数+1，否则计数-1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，从当前位置开始重复上述过程，直到扫描完全部数组元素
2. 判断c中元素是否是真正的主元素。再次扫描数组，统计c中元素出现次数，若>n/2，则为主元素，否则序列中不存在主元素

**算法实现**：

```c
int Majority(int A[], int n) {
    int i, c, count = 1; // c保存候选主元素，count计数
    c=A[0];
    for (int i = 1; i < n; i++) {
        if (A[i] == c)
            count++;
        else
            if (count > 0)
                count--;
        	else {
                c = A[i];
                count = 1;
            }
    }
    if (count > 0) {
        for (i = 0, count = 0; i<n; i++) { // 统计候选主元素的实际出现次数
            if (A[i] == c) {
                count++;
            }
        }
    }
    if (count > n/2) return c; // 确认候选主元素
    else return -1; // 不存在主元素
}
```

**其他分析**：排好序再统计O(nlogn)；O(n^2)也有10分

**<u>一眼想不出最优解就暴力，稍微扣点部分分也ok</u>**

# 2.3 线性表链式表示

## 2.3.1 单链表&基本操作

### 不带头节点

```c
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LL;

// 不带头节点
bool InitList(LL &L) {
    L = NULL;
    return true;
}

bool ListInsert(LL &L, int i, ElemType e) {
    if (i<1) return false;
    if (i == 1) {
        LNode *s = (LNode *)malloc(sizeof(LNode));
        s->data = e;
        s->next = L;
        L = s;        // 头指针指向新结点
        return true; 
    }
    // 其余差不多
    LNode *p;
    int j = 1;  // 这里起始的序号不同
    ···
}
```

### 带头节点

```c
// 写代码更方便一点
bool InitList(LL &L) {
    L = (LNode *)malloc(sizeof(LNode));
    if (L == NULL) {
        return false;
    }
    L->next = NULL;
    return true;
}

bool Empty(LL L) {
    if (L->next == NULL) { // 判断头节点的next指针
        return true;
    }
    return false;
}

// 按位序插入，i位置插入元素e，i属于[1,n+1]
void ListInsert(LL &L, int i, ElemType e) {
    if (i < 1) return false;
    LNode *p; // 指向当前扫描到的结点
    int j = 0; // p指向的是第几个结点
    p = L; // 初始化为0结点
    while(p != NULL && j < i-1) {
        // 循环找到i-1结点，将插入它下一节点
        p = p->next;
        j++;
    }
    /* 以下等价于return InsertNextNode(p, e); */
    if (p == NULL) return false; // 这里判断了i>n+1的情况
    // 最好情况：i=1，O(1)
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}

// 后插，在p结点后插入e，O(1)
bool InsertNextNode (LNode *p, ElemType e) {
    if (p==NULL) return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s == NULL) return false; // 考试可以不写
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
// 前插，如果允许改变p中数据，O(1)
// 如果不允许？那么就给出链表头遍历
bool InsertPriorNode(LNode *p, ElemType e) {
    if (p==NULL) return false;
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if (s==NULL) {
        return false;
    }
    s->next = p->next;
    p->next = s;
    s->data = p->data; // p中元素复制到s中
    p->data = e;
    return true;
}
// 按位序删除
bool ListDelete(LL &L, int i, ElemType &e) {
    if (i<1) return false;
    LNode *p;
    int j = 0;
    p = L;
    while(p!=NULL && j < i-1) { //找到i-1，即被删除的前驱
        p = p->next;
        j++;
    }
    // 最好O(1)最坏O(n)
    if (p==NULL) return false;
    if (p->next==NULL) return false; // 若i-1后已无其他结点
    LNode *q = p->next; // q指向被删除的结点
    e = q->data;
    p->next = q->next;
    free(q);
    return true;
}
// 建立链表
// 分为头插法、尾插法
// 头插法：每读一个新数据，将生成的结点插入链表表头
	// 读入顺序和链表中元素相反
// 尾插法：插入表尾 —— 需要尾指针，始终指向表尾结点
```

### 循环单链表

- 仅设置头指针：头插O(1)，尾插O(n)
- 仅设置尾指针：头插、尾插均O(1)

## 2.3.3 算法题需要注意

1. 链表的处理：尽可能减少趟数 —— 使用如双指针的技巧，达到一次遍历
2. 共享后缀找起始位置
   - 先统计两个链表的长度
   - 长的先走，走到两个链表剩余长度相同时，再一起开始走
   - 走到null/next相同时停止
   - null则没找到，next相同则起始位置就是这个next
