# 第二章 线性表

## 目录
- [第二章 线性表](#第二章-线性表)
  - [目录](#目录)
- [2.1 线性表的定义](#21-线性表的定义)
  - [2.1.1 定义](#211-定义)
  - [2.1.2 基本操作](#212-基本操作)
- [2.2 线性表的顺序表示](#22-线性表的顺序表示)
  - [2.2.1 定义](#221-定义)
  - [2.2.2 基本操作](#222-基本操作)
    - [静态分配](#静态分配)
    - [动态分配](#动态分配)
    - [一个大题整理](#一个大题整理)
- [2.3 单链表](#23-单链表)

# 2.1 线性表的定义

## 2.1.1 定义

- **相同**数据类型，n个数据元素**有限序列**
  - 表头元素、表尾元素、前驱、后继

## 2.1.2 基本操作



# 2.2 线性表的顺序表示

也称顺序表，物理位置连续

## 2.2.1 定义

- 逻辑顺序与物理顺序相同
- 主要优点
  - 随机访问
  - 存储密度高
- 缺点
  - 插入删除需移动大量元素
  - 连续存储空间，不够灵活

## 2.2.2 基本操作

在初始化前**已声明完成**

### 静态分配

- 静态“数组”存放元素

  ```c
  #define MaxSize 100
  typedef struct {
      ElemType data[MaxSize];
      int length;
  } SqList;
  
  // 初始化
  void InitList(SqList &L) {
      // 不用再次分配空间，因为声明时已分配
      L.length = 0;
  }
  
  // 插入：位置i插入指定元素e
  bool ListInsert(SqList &L, int i, ElemType e) {
      // 为了**健壮性**，加一个i范围的判断 & 存储满的判断
      // i 属于 [1, length+1] （i从1开始，数组从0开始）
      if (i < 1 || i > L.length+1) 
          return false;
      if (L.length >= MaxSize)
          return false;
      
      // 后移、插入、长度+1
      for (int j = L.length; j >= i; j--) {
          L.data[j] = L.data[j-1]; //问题规模n=L.length
      }
      L.data[i-1] = e;
      // 最好情况: i=n+1，0次
      // 最坏情况: i=1，n次
      // 平均情况: 1/(n+1) * (0+1+...+n) = n/2
      L.length++;
      return true;
  }
  
  // 删除：位置i删除给e
  bool ListDelete(SqList &L, int i, ElemType e) {
      if (i < 1 || i > L.length)
          return false;
      e = L.data[i-1];
      for (int j = i;  j < L.length; j++) {
          L.data[j-1] = L.data[j]; // 问题规模n=L.Length
      }
      // 最好情况：i=n，0次
      // 最坏情况：i=1，n-1次
      // 平均情况：1/n * (0+1+...+n-1) = (n-1)/2
      L.length--;
      return true;
  }
  
  // 按位查找
  ElemType GetElem(SqList &L, int i) {
      // 健壮性：判断i的范围
      
      // 随机访问
      return L.data[i-1];
  }
  
  // 按值查找，返回位序（由1开始的序号）
  // 最好情况1次；最坏情况n次
  // 平均 O(n)
  int LocateElem (SqList L, ElemType e) {
      int i;
      for (i = 0; i<L.length; i++) {
          if (L.data[i]==e) { // 小心结构类型的比较
              				// 按分量来比较
              return i+1;
          }
      }
      return 0;
  }
  ```

  

### 动态分配

```c
#include <stdlib.h>
#define InitSize 10
typedef struct {
    ElemType *data;
    int MaxSize;
    int length;
} SeqList;

// 初始化
void InitList(SeqList &L) {
    L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);
    L.length = 0;
    L.MaxSize = InitSize;
}

void IncreaseSize(SeqList &L, int len) {
	// 申请新区域
    ElemType *p = L.data;
    // 数据复制
    L.data = (ElemType *)malloc(~~~);
    for (int i = 0; i < L.length; i++) {
        L.data[i] = p[i];
    }
    L.MaxSize = L.MaxSize + len;
    // 释放原有内存空间
    free(p);
}
```

### 一个大题整理

**题面**：整数序列、寻找主元素，若存在则输出，若不存在则输出-1

**标答**（经典必背）：

1. 选取候选的主元素。依次扫描数组中每个整数，将遇到的第一个整数Num保存到c中，记录Num出现次数记为1；若遇到的下一个整数仍等于Num，则计数+1，否则计数-1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，从当前位置开始重复上述过程，直到扫描完全部数组元素
2. 判断c中元素是否是真正的主元素。再次扫描数组，统计c中元素出现次数，若>n/2，则为主元素，否则序列中不存在主元素

**算法实现**：

```c
int Majority(int A[], int n) {
    int i, c, count = 1; // c保存候选主元素，count计数
    c=A[0];
    for (int i = 1; i < n; i++) {
        if (A[i] == c)
            count++;
        else
            if (count > 0)
                count--;
        	else {
                c = A[i];
                count = 1;
            }
    }
    if (count > 0) {
        for (i = 0, count = 0; i<n; i++) { // 统计候选主元素的实际出现次数
            if (A[i] == c) {
                count++;
            }
        }
    }
    if (count > n/2) return c; // 确认候选主元素
    else return -1; // 不存在主元素
}
```

**其他分析**：排好序再统计O(nlogn)；O(n^2)也有10分

**<u>一眼想不出最优解就暴力，稍微扣点部分分也ok</u>**

# 2.3 单链表
