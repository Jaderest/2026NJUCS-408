# 第五章 树与二叉树

## 目录
- [第五章 树与二叉树](#第五章-树与二叉树)
  - [目录](#目录)
- [5.1 树的基本概念](#51-树的基本概念)
- [5.2 二叉树的基本概念](#52-二叉树的基本概念)
  - [特殊二叉树](#特殊二叉树)
  - [二叉树存储结构](#二叉树存储结构)
    - [顺序存储](#顺序存储)
  - [一些易错点](#一些易错点)
- [5.3 树的遍历与线索化](#53-树的遍历与线索化)
    - [后序线索二叉树中线索的指向](#后序线索二叉树中线索的指向)
    - [一些关于NLR、LNR、LRN性质的分析](#一些关于nlrlnrlrn性质的分析)
    - [先序序列为abcd的不同二叉树个数为](#先序序列为abcd的不同二叉树个数为)
    - [算法整理](#算法整理)

# 5.1 树的基本概念

- 树的度：树中结点的最大度数
- 树的路径长度：从根节点到所有叶结点的路径长度之和 —— 注意区别霍夫曼树
- n个结点的树，度为n-1
- 关于n个结点、度为m、分析树的高度h最小最大
  - 或度为m，高为h，分析结点n的最大最小
- 一点小技巧
  - 森林中每颗树让 n-m 增大1，例如25个结点、15条边的森林中有 25 - 15 = 10棵树
  - 分析树上叶结点的个数
    - 每个度为m的结点让叶结点增多m-1；基础叶节点个数为1
    - 于是m叉树中，N1个度数为1的结点、N2个度2、...、Nm个度m，叶结点个数为$\Sigma^m_{i=2}(i-1)Ni+1$

# 5.2 二叉树的基本概念

## 特殊二叉树

- 满二叉树
- 完全二叉树
- 二叉排序树
- 平衡二叉树
- 正则二叉树：结点的子结点树为0或2

## 二叉树存储结构

### 顺序存储

- 完全二叉树
- 一般二叉树
  - **如果必定会占到h层，为了保证它的任意性，它所需的空间和h层完全二叉树相同**
  - 例如5层有10个结点的二叉树：我们不能限定它的形状，所以它在5层的结点分布是任意的；需要和5层完全二叉树相同的空间

## 一些易错点

- 124个叶节点的完全二叉树最多多少个结点？
  - 小心一个叶结点若改为有一个子结点，**则总叶结点个数并不改变**，所以算最多结点时需要注意是否能加这一个子节点

- 遇到问树的性质的，多考虑一下根结点

# 5.3 树的遍历与线索化

### 后序线索二叉树中线索的指向

后序线索二叉树中找结点的后继，分为三种情况：

1. 若结点x是二叉树的根，则后继为空
2. 若结点x是右孩子/x是左孩子且其父结点无右子树 -> 后继为父结点
3. x是左孩子，父结点有右子树，则其后继为双亲右子树后续遍历列出的第一个结点

![后序线索二叉树](./5-pic/后序线索二叉树.png)

- 如图中B，B的后继无法通过链域找到，B的后继是F
- **后序线索树的遍历需要栈的支持**

### 一些关于NLR、LNR、LRN性质的分析

- 先序序列与中序序列完全相同：NLR=LNR -> L为空，每个结点都只有右子树或没有
- 后序序列与中序序列完全相同：LNR=LRN -> R为空
- 前序与后序序列中若出现
  - 前序...p...q...；后序...q...p...   
  - 由<u>N</u> <u>LR</u>和<u>LR</u> <u>N</u>可知p必定是q的祖先，因为只有为祖先后代关系，二者顺序才会倒过来

### 先序序列为abcd的不同二叉树个数为

- 首先了解前序遍历和中序遍历的过程：前序遍历相当于入栈次序、中序遍历相当于出栈次序
- 所以给定入栈次序的长度，出栈次序的个数也确定了
- 出栈次序=中序次序 + 入栈次序 = 唯一确定二叉树
- **出栈次序数量 = 二叉树个数**
- 入栈长n，二叉树个数$\frac{1}{n+1}C_{2n}^{n}$，卡特兰树

### 算法整理

- 中序遍历为递增序列的二叉树T，若想构造一个中序遍历为递减序列的二叉树T'
  - 只需要交换所有结点的左右子树
  - 那么我们实现这种算法：采用后序遍历，先处理完所有左右子树，然后再处理这个根，递归往上走

- 求WPL：树上所有叶结点的带权路径之和
  - 中间结点不用管
  - 只要管叶结点即可

- 判断一个顺序存储的二叉树是否是搜索二叉树

  ```c
  // val记录中序遍历中已遍历结点的最大值，初值为一个负整数。若当前遍历的结点值小于等于val，则返回false，否则更新val值
  bool judge(SqBiTree bt, int k, int *val) { 
      // 初始调用k为0，从根出发
      if (k < bt.ElemNum && bt.SqBiTNode[k] != -1) {
          if(!judge(bt, 2*k+1, val)) return false;
          if(bt.SqBiTNode[k]<=*val) return false;
          *val = bt.SqBiTNode[k];
          if(!judge(bt, 2*k+2, val)) return false;
      }
      return false;
  }
  ```
